{"MonoBehaviour":{"m_Enabled":true,"m_EditorHideFlags":0,"m_Name":"","m_EditorClassIdentifier":"","entries":[{"srpTarget":0,"UnityVersionMin":0,"UnityVersionMax":30000,"shader":{"fileID":4800000,"guid":"2f7ccbeaaba454367b4d71f470c1d225","type":3},"shaderSrc":"// Upgrade NOTE: replaced 'defined FOG_COMBINED_WITH_WORLD_POS' with 'defined (FOG_COMBINED_WITH_WORLD_POS)'\n\nShader \"BetterShaders/Standard\"\n{\n   Properties\n   {\n         _AlbedoMap(\"Albedo\", 2D) = \"white\" {}\n\t_Tint (\"Tint\", Color) = (1, 1, 1, 1)\n   \n   [Normal][NoScaleOffset]_NormalMap(\"Normal\", 2D) = \"bump\" {}\n   _NormalStrength(\"Normal Strength\", Range(0,2)) = 1\n\n   [Toggle(_MASKMAP)]\n   _UseMaskMap (\"Use Mask Map\", Float) = 0\n   [NoScaleOffset]_MaskMap(\"Mask Map\", 2D) = \"black\" {}\n\n   [Toggle(_EMISSION)]\n   _UseEmission (\"Use Emission Map\", Float) = 0\n   [NoScaleOffset]_EmissionMap(\"Emission Map\", 2D) = \"black\" {}\n   _EmissionStrength(\"Emission Strength\", Range(0, 4)) = 1\n\n   [Toggle(_DETAIL)]\n   _UseDetail(\"Use Detail Map\", Float) = 0\n   _DetailMap(\"Detail Map\", 2D) = \"bump\" {}\n   _DetailAlbedoStrength(\"Detail Albedo Strength\", Range(0, 2)) = 1\n   _DetailNormalStrength(\"Detail Normal Strength\", Range(0, 2)) = 1\n   _DetailSmoothnessStrength(\"Detail Smoothness Strength\", Range(0, 2)) = 1\n\n\n   }\n   SubShader\n   {\n      Tags { \"RenderType\" = \"Opaque\" \"Queue\" = \"Geometry\" }\n\n      \n      Pass\n      {\n\t\t   Name \"FORWARD\"\n\t\t   Tags { \"LightMode\" = \"ForwardBase\" }\n         \n\n         CGPROGRAM\n         // compile directives\n            #pragma vertex Vert\n   #pragma fragment Frag\n\n         #pragma target 3.0\n         #pragma multi_compile_instancing\n         #pragma multi_compile_fog\n         #pragma multi_compile_fwdbase\n         #include \"HLSLSupport.cginc\"\n         #define UNITY_INSTANCED_LOD_FADE\n         #define UNITY_INSTANCED_SH\n         #define UNITY_INSTANCED_LIGHTMAPSTS\n\n         #include \"UnityShaderVariables.cginc\"\n         #include \"UnityShaderUtilities.cginc\"\n         // -------- variant for: <when no other keywords are defined>\n\n         #include \"UnityCG.cginc\"\n         #include \"Lighting.cginc\"\n         #include \"UnityPBSLighting.cginc\"\n         #include \"AutoLight.cginc\"\n\n            #pragma shader_feature_local _ _MASKMAP\n   #pragma shader_feature_local _ _DETAIL\n   #pragma shader_feature_local _ _EMISSION\n\n   #define _STANDARD 1\n\n\n\n         \n\n         // data across stages, stripped like the above.\n         struct VertexToPixel\n         {\n            UNITY_POSITION(pos);\n            float3 worldPos : TEXCOORD0;\n            float3 worldNormal : TEXCOORD1;\n            float4 worldTangent : TEXCOORD2;\n             float4 texcoord0 : TEXCCOORD3;\n            // float4 texcoord1 : TEXCCOORD4;\n            // float4 texcoord2 : TEXCCOORD5;\n            // float4 texcoord3 : TEXCCOORD6;\n            // float4 screenPos : TEXCOORD7;\n            // float4 color : COLOR;\n            float4 lmap : TEXCOORD8;\n            #if UNITY_SHOULD_SAMPLE_SH\n               half3 sh : TEXCOORD9; // SH\n            #endif\n            #ifdef LIGHTMAP_ON\n               UNITY_LIGHTING_COORDS(10,11)\n            #else\n               UNITY_FOG_COORDS(10)\n               UNITY_SHADOW_COORDS(11)\n            #endif\n\n            // float4 extraData0 : TEXCOORD12;\n            // float4 extraData1 : TEXCOORD13;\n            // float4 extraData2 : TEXCOORD14;\n            // float4 extraData3 : TEXCOORD15;\n\n\n            UNITY_VERTEX_INPUT_INSTANCE_ID\n            UNITY_VERTEX_OUTPUT_STEREO\n         };\n\n         \n            \n            // data describing the user output of a pixel\n            struct LightingInputs\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half Alpha;\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half Anisotropy;\n               half iridescenceMask;\n               half iridescenceThickness;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n\n               float3x3 TBNMatrix;\n            };\n\n            struct VertexData\n            {\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n            \n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n\n               \n               // float4 extraData0 : TEXCOORD4;\n               // float4 extraData1 : TEXCOORD5;\n               // float4 extraData2 : TEXCOORD6;\n               // float4 extraData3 : TEXCOORD7;\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraData\n            {\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, p); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n            #endif\n\n\n            \n         \thalf4 _Tint;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half _EmissionStrength;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n\n\n         \n   half3 BlendDetailNormal(half3 n1, half3 n2)\n   {\n      return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n   }\n\n   // We share samplers with the albedo - which free's up more for stacking.\n\n   UNITY_DECLARE_TEX2D(_AlbedoMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_NormalMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_MaskMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_EmissionMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_DetailMap);\n\n\n\tvoid SurfaceFunction(inout LightingInputs o, ShaderData d)\n\t{\n      float2 uv = d.texcoord0.xy * _AlbedoMap_ST.xy + _AlbedoMap_ST.zw;\n\n      half4 c = UNITY_SAMPLE_TEX2D(_AlbedoMap, uv);\n      o.Albedo = c.rgb * _Tint.rgb;\n\t\to.Normal = UnpackScaleNormal(UNITY_SAMPLE_TEX2D_SAMPLER(_NormalMap, _AlbedoMap, uv), _NormalStrength);\n\n      half detailMask = 1;\n      #if _MASKMAP\n          // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = UNITY_SAMPLE_TEX2D_SAMPLER(_MaskMap, _AlbedoMap, uv);\n         o.Metallic = mask.r;\n         o.Occlusion = mask.g;\n         o.Smoothness = mask.a;\n         detailMask = mask.b;\n      #endif // separate maps\n\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap, _AlbedoMap, uv).rgb * _EmissionStrength;\n      #endif\n\n      #if defined(_DETAIL)\n         float2 detailUV = uv * _DetailMap_ST.xy + _DetailMap_ST.zw;\n         half4 detailSample = UNITY_SAMPLE_TEX2D_SAMPLER(_DetailMap, _AlbedoMap, detailUV);\n         o.Normal = BlendDetailNormal(o.Normal, UnpackScaleNormal(detailSample, _DetailNormalStrength * detailMask));\n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * detailSample.z, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n\n\t\to.Alpha = c.a;\n\t}\n\n\n\n        \n            void ChainSurfaceFunction(inout LightingInputs l, ShaderData d)\n            {\n                   SurfaceFunction(l, d);\n                 // SurfaceFunction_Ext1(l, d);\n                 // SurfaceFunction_Ext2(l, d);\n                 // SurfaceFunction_Ext3(l, d);\n                 // SurfaceFunction_Ext4(l, d);\n                 // SurfaceFunction_Ext5(l, d);\n                 // SurfaceFunction_Ext6(l, d);\n                 // SurfaceFunction_Ext7(l, d);\n                 // SurfaceFunction_Ext8(l, d);\n                 // SurfaceFunction_Ext9(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraData d = (ExtraData)0;\n                 //  ModifyVertex(v, d);\n                 // ModifyVertex_Ext1(v, d);\n                 // ModifyVertex_Ext2(v, d);\n                 // ModifyVertex_Ext3(v, d);\n                 // ModifyVertex_Ext4(v, d);\n                 // ModifyVertex_Ext5(v, d);\n                 // ModifyVertex_Ext6(v, d);\n                 // ModifyVertex_Ext7(v, d);\n                 // ModifyVertex_Ext8(v, d);\n                 // ModifyVertex_Ext9(v, d);\n                 // v2p.extraData0 = d.extraData0;\n                 // v2p.extraData1 = d.extraData1;\n                 // v2p.extraData2 = d.extraData2;\n                 // v2p.extraData3 = d.extraData3;\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraData d = (ExtraData)0;\n               //  ModifyTessellatedVertex(v, d);\n               // ModifyTessellatedVertex_Ext1(v, d);\n               // ModifyTessellatedVertex_Ext2(v, d);\n               // ModifyTessellatedVertex_Ext3(v, d);\n               // ModifyTessellatedVertex_Ext4(v, d);\n               // ModifyTessellatedVertex_Ext5(v, d);\n               // ModifyTessellatedVertex_Ext6(v, d);\n               // ModifyTessellatedVertex_Ext7(v, d);\n               // ModifyTessellatedVertex_Ext8(v, d);\n               // ModifyTessellatedVertex_Ext9(v, d);\n               // v2p.extraData0 = d.extraData0;\n               // v2p.extraData1 = d.extraData1;\n               // v2p.extraData2 = d.extraData2;\n               // v2p.extraData3 = d.extraData3;\n            }\n\n\n\n         \n\n         ShaderData CreateShaderData(VertexToPixel i)\n         {\n            ShaderData d = (ShaderData)0;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = i.worldNormal;\n            d.worldSpaceTangent = i.worldTangent.xyz;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n            // d.texcoord3 = i.texcoord3;\n            // d.vertexColor = i.color;\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            // d.localSpacePosition = mul(unity_WorldToObject, i.worldPos);\n            // d.localSpaceNormal = mul(unity_WorldToObject, i.worldNormal);\n            // d.localSpaceTangent = mul(unity_WorldToObject, i.worldTangent.xyz);\n\n            // d.screenPos = i.screenPos;\n            // d.screenUV = i.screenPos.xy / i.screenPos.w;\n\n            // d.extraData0 = i.extraData0;\n            // d.extraData1 = i.extraData1;\n            // d.extraData2 = i.extraData2;\n            // d.extraData3 = i.extraData3;\n\n            return d;\n         }\n         \n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           UNITY_SETUP_INSTANCE_ID(v);\n           VertexToPixel o;\n           UNITY_INITIALIZE_OUTPUT(VertexToPixel,o);\n           UNITY_TRANSFER_INSTANCE_ID(v,o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o);\n#endif\n\n           o.pos = UnityObjectToClipPos(v.vertex);\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n           // o.texcoord3 = v.texcoord3;\n           // o.color = v.color;\n           // o.screenPos = ComputeScreenPos(o.pos);\n           o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n           o.worldNormal = UnityObjectToWorldNormal(v.normal);\n           o.worldTangent.xyz = UnityObjectToWorldDir(v.tangent.xyz);\n           fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n           o.worldTangent.w = tangentSign;\n\n           #ifdef DYNAMICLIGHTMAP_ON\n           o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n           #endif\n           #ifdef LIGHTMAP_ON\n           o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n           #endif\n\n           // SH/ambient and vertex lights\n           #ifndef LIGHTMAP_ON\n             #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n               o.sh = 0;\n               // Approximated illumination from non-important point lights\n               #ifdef VERTEXLIGHT_ON\n                 o.sh += Shade4PointLights (\n                   unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,\n                   unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n                   unity_4LightAtten0, o.worldPos, o.worldNormal);\n               #endif\n               o.sh = ShadeSHPerVertex (o.worldNormal, o.sh);\n             #endif\n           #endif // !LIGHTMAP_ON\n\n           UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader\n           #ifdef FOG_COMBINED_WITH_TSPACE\n             UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader\n           #elif defined (FOG_COMBINED_WITH_WORLD_POS)\n             UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader\n           #else\n             UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader\n           #endif\n\n           return o;\n         }\n\n         \n\n         // fragment shader\n         fixed4 Frag (VertexToPixel IN) : SV_Target\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           // prepare and unpack data\n           #ifdef FOG_COMBINED_WITH_TSPACE\n             UNITY_EXTRACT_FOG_FROM_TSPACE(IN);\n           #elif defined (FOG_COMBINED_WITH_WORLD_POS)\n             UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);\n           #else\n             UNITY_EXTRACT_FOG(IN);\n           #endif\n\n           ShaderData d = CreateShaderData(IN);\n\n           LightingInputs l = (LightingInputs)0;\n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n\n           #ifndef USING_DIRECTIONAL_LIGHT\n             fixed3 lightDir = normalize(UnityWorldSpaceLightDir(d.worldSpacePosition));\n           #else\n             fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n           #endif\n           float3 worldViewDir = normalize(UnityWorldSpaceViewDir(d.worldSpacePosition));\n\n           // compute lighting & shadowing factor\n           UNITY_LIGHT_ATTENUATION(atten, IN, d.worldSpacePosition)\n\n           #if _USESPECULAR\n              #ifdef UNITY_COMPILER_HLSL\n              SurfaceOutputStandardSpecular o = (SurfaceOutputStandardSpecular)0;\n              #else\n              SurfaceOutputStandardSpecular o;\n              #endif\n              o.Specular = l.Specular;\n           #else\n              #ifdef UNITY_COMPILER_HLSL\n              SurfaceOutputStandard o = (SurfaceOutputStandard)0;\n              #else\n              SurfaceOutputStandard o;\n              #endif\n              o.Metallic = l.Metallic;\n           #endif\n\n           o.Albedo = l.Albedo;\n           o.Emission = l.Emission;\n           o.Alpha = l.Alpha;\n           o.Occlusion = l.Occlusion;\n\n           \n           o.Normal = normalize(TangentToWorldSpace(d, l.Normal));\n\n           fixed4 c = 0;\n           // Setup lighting environment\n           UnityGI gi;\n           UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n           gi.indirect.diffuse = 0;\n           gi.indirect.specular = 0;\n           gi.light.color = _LightColor0.rgb;\n           gi.light.dir = lightDir;\n           // Call GI (lightmaps/SH/reflections) lighting function\n           UnityGIInput giInput;\n           UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n           giInput.light = gi.light;\n           giInput.worldPos = d.worldSpacePosition;\n           giInput.worldViewDir = worldViewDir;\n           giInput.atten = atten;\n           #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n             giInput.lightmapUV = IN.lmap;\n           #else\n             giInput.lightmapUV = 0.0;\n           #endif\n           #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n             giInput.ambient = IN.sh;\n           #else\n             giInput.ambient.rgb = 0.0;\n           #endif\n           giInput.probeHDR[0] = unity_SpecCube0_HDR;\n           giInput.probeHDR[1] = unity_SpecCube1_HDR;\n           #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n             giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending\n           #endif\n           #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n             giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n             giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n             giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n             giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n             giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n           #endif\n           \n\n           #if _USESPECULAR\n              LightingStandardSpecular_GI(o, giInput, gi);\n              c += LightingStandardSpecular (o, worldViewDir, gi);\n           #else\n              LightingStandard_GI(o, giInput, gi);\n              c += LightingStandard (o, worldViewDir, gi);\n           #endif\n\n           c.rgb += o.Emission;\n\n           UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog\n           \n           #if !_ALPHABLEND_ON\n              UNITY_OPAQUE_ALPHA(c.a);\n           #endif\n           \n           return c;\n         }\n\n         ENDCG\n\n      }\n\n\t   // ---- forward rendering additive lights pass:\n\t   Pass\n      {\n\t\t   Name \"FORWARD\"\n\t\t   Tags { \"LightMode\" = \"ForwardAdd\" }\n\t\t   ZWrite Off Blend One One\n         \n\t\t\n         CGPROGRAM\n\n            #pragma vertex Vert\n   #pragma fragment Frag\n\n         // compile directives\n         #pragma target 3.0\n         #pragma multi_compile_instancing\n         #pragma multi_compile_fog\n         #pragma skip_variants INSTANCING_ON\n         #pragma multi_compile_fwdadd_fullshadows\n         #include \"HLSLSupport.cginc\"\n         #define UNITY_INSTANCED_LOD_FADE\n         #define UNITY_INSTANCED_SH\n         #define UNITY_INSTANCED_LIGHTMAPSTS\n         #include \"UnityShaderVariables.cginc\"\n         #include \"UnityShaderUtilities.cginc\"\n\n\n         #include \"UnityCG.cginc\"\n         #include \"Lighting.cginc\"\n         #include \"UnityPBSLighting.cginc\"\n         #include \"AutoLight.cginc\"\n\n            #pragma shader_feature_local _ _MASKMAP\n   #pragma shader_feature_local _ _DETAIL\n   #pragma shader_feature_local _ _EMISSION\n\n   #define _STANDARD 1\n\n\n         // data across stages, stripped like the above.\n         struct VertexToPixel\n         {\n            UNITY_POSITION(pos);       // must be named pos because Unity does stupid macro stuff\n            float3 worldPos : TEXCOORD0;\n            float3 worldNormal : TEXCOORD1;\n            float4 worldTangent : TEXCOORD2;\n             float4 texcoord0 : TEXCCOORD3;\n            // float4 texcoord1 : TEXCCOORD4;\n            // float4 texcoord2 : TEXCCOORD5;\n            // float4 texcoord3 : TEXCCOORD6;\n            // float4 screenPos : TEXCOORD7;\n            // float4 color : COLOR;\n\n            float4 lmap : TEXCOORD8;\n            #if UNITY_SHOULD_SAMPLE_SH\n               half3 sh : TEXCOORD9; // SH\n            #endif\n\n            UNITY_LIGHTING_COORDS(10,11)\n            UNITY_VERTEX_INPUT_INSTANCE_ID\n            UNITY_VERTEX_OUTPUT_STEREO\n\n         };\n\n         \n            \n            // data describing the user output of a pixel\n            struct LightingInputs\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half Alpha;\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half Anisotropy;\n               half iridescenceMask;\n               half iridescenceThickness;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n\n               float3x3 TBNMatrix;\n            };\n\n            struct VertexData\n            {\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n            \n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n\n               \n               // float4 extraData0 : TEXCOORD4;\n               // float4 extraData1 : TEXCOORD5;\n               // float4 extraData2 : TEXCOORD6;\n               // float4 extraData3 : TEXCOORD7;\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraData\n            {\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, p); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n            #endif\n\n\n            \n         \thalf4 _Tint;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half _EmissionStrength;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n\n\n         \n   half3 BlendDetailNormal(half3 n1, half3 n2)\n   {\n      return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n   }\n\n   // We share samplers with the albedo - which free's up more for stacking.\n\n   UNITY_DECLARE_TEX2D(_AlbedoMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_NormalMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_MaskMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_EmissionMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_DetailMap);\n\n\n\tvoid SurfaceFunction(inout LightingInputs o, ShaderData d)\n\t{\n      float2 uv = d.texcoord0.xy * _AlbedoMap_ST.xy + _AlbedoMap_ST.zw;\n\n      half4 c = UNITY_SAMPLE_TEX2D(_AlbedoMap, uv);\n      o.Albedo = c.rgb * _Tint.rgb;\n\t\to.Normal = UnpackScaleNormal(UNITY_SAMPLE_TEX2D_SAMPLER(_NormalMap, _AlbedoMap, uv), _NormalStrength);\n\n      half detailMask = 1;\n      #if _MASKMAP\n          // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = UNITY_SAMPLE_TEX2D_SAMPLER(_MaskMap, _AlbedoMap, uv);\n         o.Metallic = mask.r;\n         o.Occlusion = mask.g;\n         o.Smoothness = mask.a;\n         detailMask = mask.b;\n      #endif // separate maps\n\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap, _AlbedoMap, uv).rgb * _EmissionStrength;\n      #endif\n\n      #if defined(_DETAIL)\n         float2 detailUV = uv * _DetailMap_ST.xy + _DetailMap_ST.zw;\n         half4 detailSample = UNITY_SAMPLE_TEX2D_SAMPLER(_DetailMap, _AlbedoMap, detailUV);\n         o.Normal = BlendDetailNormal(o.Normal, UnpackScaleNormal(detailSample, _DetailNormalStrength * detailMask));\n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * detailSample.z, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n\n\t\to.Alpha = c.a;\n\t}\n\n\n\n        \n            void ChainSurfaceFunction(inout LightingInputs l, ShaderData d)\n            {\n                   SurfaceFunction(l, d);\n                 // SurfaceFunction_Ext1(l, d);\n                 // SurfaceFunction_Ext2(l, d);\n                 // SurfaceFunction_Ext3(l, d);\n                 // SurfaceFunction_Ext4(l, d);\n                 // SurfaceFunction_Ext5(l, d);\n                 // SurfaceFunction_Ext6(l, d);\n                 // SurfaceFunction_Ext7(l, d);\n                 // SurfaceFunction_Ext8(l, d);\n                 // SurfaceFunction_Ext9(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraData d = (ExtraData)0;\n                 //  ModifyVertex(v, d);\n                 // ModifyVertex_Ext1(v, d);\n                 // ModifyVertex_Ext2(v, d);\n                 // ModifyVertex_Ext3(v, d);\n                 // ModifyVertex_Ext4(v, d);\n                 // ModifyVertex_Ext5(v, d);\n                 // ModifyVertex_Ext6(v, d);\n                 // ModifyVertex_Ext7(v, d);\n                 // ModifyVertex_Ext8(v, d);\n                 // ModifyVertex_Ext9(v, d);\n                 // v2p.extraData0 = d.extraData0;\n                 // v2p.extraData1 = d.extraData1;\n                 // v2p.extraData2 = d.extraData2;\n                 // v2p.extraData3 = d.extraData3;\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraData d = (ExtraData)0;\n               //  ModifyTessellatedVertex(v, d);\n               // ModifyTessellatedVertex_Ext1(v, d);\n               // ModifyTessellatedVertex_Ext2(v, d);\n               // ModifyTessellatedVertex_Ext3(v, d);\n               // ModifyTessellatedVertex_Ext4(v, d);\n               // ModifyTessellatedVertex_Ext5(v, d);\n               // ModifyTessellatedVertex_Ext6(v, d);\n               // ModifyTessellatedVertex_Ext7(v, d);\n               // ModifyTessellatedVertex_Ext8(v, d);\n               // ModifyTessellatedVertex_Ext9(v, d);\n               // v2p.extraData0 = d.extraData0;\n               // v2p.extraData1 = d.extraData1;\n               // v2p.extraData2 = d.extraData2;\n               // v2p.extraData3 = d.extraData3;\n            }\n\n\n         \n         \n\n         ShaderData CreateShaderData(VertexToPixel i)\n         {\n            ShaderData d = (ShaderData)0;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = i.worldNormal;\n            d.worldSpaceTangent = i.worldTangent.xyz;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n            // d.texcoord3 = i.texcoord3;\n            // d.vertexColor = i.color;\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            // d.localSpacePosition = mul(unity_WorldToObject, i.worldPos);\n            // d.localSpaceNormal = mul(unity_WorldToObject, i.worldNormal);\n            // d.localSpaceTangent = mul(unity_WorldToObject, i.worldTangent.xyz);\n\n            // d.screenPos = i.screenPos;\n            // d.screenUV = i.screenPos.xy / i.screenPos.w;\n\n            // d.extraData0 = i.extraData0;\n            // d.extraData1 = i.extraData1;\n            // d.extraData2 = i.extraData2;\n            // d.extraData3 = i.extraData3;\n\n            return d;\n         }\n         \n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           UNITY_SETUP_INSTANCE_ID(v);\n           VertexToPixel o;\n           UNITY_INITIALIZE_OUTPUT(VertexToPixel,o);\n           UNITY_TRANSFER_INSTANCE_ID(v,o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o);\n#endif\n\n           o.pos = UnityObjectToClipPos(v.vertex);\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n           // o.texcoord3 = v.texcoord3;\n           // o.color = v.color;\n           // o.screenPos = ComputeScreenPos(o.pos);\n           o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n           o.worldNormal = UnityObjectToWorldNormal(v.normal);\n           o.worldTangent.xyz = UnityObjectToWorldDir(v.tangent.xyz);\n           fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n           o.worldTangent.w = tangentSign;\n\n           UNITY_TRANSFER_LIGHTING(o, v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader\n           UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader\n\n           return o;\n         }\n\n         \n\n         // fragment shader\n         fixed4 Frag (VertexToPixel IN) : SV_Target\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           // prepare and unpack data\n\n           #ifdef FOG_COMBINED_WITH_TSPACE\n             UNITY_EXTRACT_FOG_FROM_TSPACE(IN);\n           #elif defined (FOG_COMBINED_WITH_WORLD_POS)\n             UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);\n           #else\n             UNITY_EXTRACT_FOG(IN);\n           #endif\n\n\n\n           ShaderData d = CreateShaderData(IN);\n\n           LightingInputs l = (LightingInputs)0;\n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n\n           #ifndef USING_DIRECTIONAL_LIGHT\n             fixed3 lightDir = normalize(UnityWorldSpaceLightDir(d.worldSpacePosition));\n           #else\n             fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n           #endif\n           float3 worldViewDir = normalize(UnityWorldSpaceViewDir(d.worldSpacePosition));\n\n           #if _USESPECULAR\n              #ifdef UNITY_COMPILER_HLSL\n              SurfaceOutputStandardSpecular o = (SurfaceOutputStandardSpecular)0;\n              #else\n              SurfaceOutputStandardSpecular o;\n              #endif\n              o.Specular = l.Specular;\n           #else\n              #ifdef UNITY_COMPILER_HLSL\n              SurfaceOutputStandard o = (SurfaceOutputStandard)0;\n              #else\n              SurfaceOutputStandard o;\n              #endif\n              o.Metallic = l.Metallic;\n           #endif\n\n   \n\n           o.Albedo = l.Albedo;\n           o.Emission = l.Emission;\n           o.Alpha = l.Alpha;\n           o.Occlusion = l.Occlusion;\n           o.Normal = normalize(TangentToWorldSpace(d, l.Normal));\n\n           UNITY_LIGHT_ATTENUATION(atten, IN, d.worldSpacePosition)\n           fixed4 c = 0;\n\n           // Setup lighting environment\n           UnityGI gi;\n           UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n           gi.indirect.diffuse = 0;\n           gi.indirect.specular = 0;\n           gi.light.color = _LightColor0.rgb;\n           gi.light.dir = lightDir;\n           gi.light.color *= atten;\n\n\n           #if _USESPECULAR\n              c += LightingStandardSpecular (o, worldViewDir, gi);\n           #else\n              c += LightingStandard (o, worldViewDir, gi);\n           #endif\n\n           UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog\n\n           // FinalColorForward(l, d, c);\n\n           #if !_ALPHABLEND_ON\n              UNITY_OPAQUE_ALPHA(c.a);\n           #endif\n           \n           return c;\n         }\n\n         ENDCG\n\n      }\n\n      \n\t   // ---- deferred shading pass:\n\t   Pass\n      {\n\t\t   Name \"DEFERRED\"\n\t\t   Tags { \"LightMode\" = \"Deferred\" }\n\n         CGPROGRAM\n\n            #pragma vertex Vert\n   #pragma fragment Frag\n\n         // compile directives\n         #pragma target 3.0\n         #pragma multi_compile_instancing\n         #pragma exclude_renderers nomrt\n         #pragma skip_variants FOG_LINEAR FOG_EXP FOG_EXP2\n         #pragma multi_compile_prepassfinal\n         #include \"HLSLSupport.cginc\"\n         #define UNITY_INSTANCED_LOD_FADE\n         #define UNITY_INSTANCED_SH\n         #define UNITY_INSTANCED_LIGHTMAPSTS\n         #include \"UnityShaderVariables.cginc\"\n         #include \"UnityShaderUtilities.cginc\"\n         #include \"UnityCG.cginc\"\n         #include \"Lighting.cginc\"\n         #include \"UnityPBSLighting.cginc\"\n\n            #pragma shader_feature_local _ _MASKMAP\n   #pragma shader_feature_local _ _DETAIL\n   #pragma shader_feature_local _ _EMISSION\n\n   #define _STANDARD 1\n\n         \n\n         // data across stages, stripped like the above.\n         struct VertexToPixel\n         {\n            UNITY_POSITION(pos);       // must be named pos because Unity does stupid macro stuff\n            float3 worldPos : TEXCOORD0;\n            float3 worldNormal : TEXCOORD1;\n            float4 worldTangent : TEXCOORD2;\n             float4 texcoord0 : TEXCCOORD3;\n            // float4 texcoord1 : TEXCCOORD4;\n            // float4 texcoord2 : TEXCCOORD5;\n            // float4 texcoord3 : TEXCCOORD6;\n            // float4 screenPos : TEXCOORD7;\n            // float4 color : COLOR;\n\n            #ifndef DIRLIGHTMAP_OFF\n              float3 viewDir : TEXCOORD8;\n            #endif\n            float4 lmap : TEXCOORD9;\n            #ifndef LIGHTMAP_ON\n              #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n                half3 sh : TEXCOORD10; // SH\n              #endif\n            #else\n              #ifdef DIRLIGHTMAP_OFF\n                float4 lmapFadePos : TEXCOORD11;\n              #endif\n            #endif\n\n            // float4 extraData0 : TEXCOORD12;\n            // float4 extraData1 : TEXCOORD13;\n            // float4 extraData2 : TEXCOORD14;\n            // float4 extraData3 : TEXCOORD15;\n\n            UNITY_VERTEX_INPUT_INSTANCE_ID\n            UNITY_VERTEX_OUTPUT_STEREO\n         };\n\n         \n            \n            // data describing the user output of a pixel\n            struct LightingInputs\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half Alpha;\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half Anisotropy;\n               half iridescenceMask;\n               half iridescenceThickness;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n\n               float3x3 TBNMatrix;\n            };\n\n            struct VertexData\n            {\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n            \n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n\n               \n               // float4 extraData0 : TEXCOORD4;\n               // float4 extraData1 : TEXCOORD5;\n               // float4 extraData2 : TEXCOORD6;\n               // float4 extraData3 : TEXCOORD7;\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraData\n            {\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, p); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n            #endif\n\n\n            \n         \thalf4 _Tint;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half _EmissionStrength;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n\n\n         \n   half3 BlendDetailNormal(half3 n1, half3 n2)\n   {\n      return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n   }\n\n   // We share samplers with the albedo - which free's up more for stacking.\n\n   UNITY_DECLARE_TEX2D(_AlbedoMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_NormalMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_MaskMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_EmissionMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_DetailMap);\n\n\n\tvoid SurfaceFunction(inout LightingInputs o, ShaderData d)\n\t{\n      float2 uv = d.texcoord0.xy * _AlbedoMap_ST.xy + _AlbedoMap_ST.zw;\n\n      half4 c = UNITY_SAMPLE_TEX2D(_AlbedoMap, uv);\n      o.Albedo = c.rgb * _Tint.rgb;\n\t\to.Normal = UnpackScaleNormal(UNITY_SAMPLE_TEX2D_SAMPLER(_NormalMap, _AlbedoMap, uv), _NormalStrength);\n\n      half detailMask = 1;\n      #if _MASKMAP\n          // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = UNITY_SAMPLE_TEX2D_SAMPLER(_MaskMap, _AlbedoMap, uv);\n         o.Metallic = mask.r;\n         o.Occlusion = mask.g;\n         o.Smoothness = mask.a;\n         detailMask = mask.b;\n      #endif // separate maps\n\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap, _AlbedoMap, uv).rgb * _EmissionStrength;\n      #endif\n\n      #if defined(_DETAIL)\n         float2 detailUV = uv * _DetailMap_ST.xy + _DetailMap_ST.zw;\n         half4 detailSample = UNITY_SAMPLE_TEX2D_SAMPLER(_DetailMap, _AlbedoMap, detailUV);\n         o.Normal = BlendDetailNormal(o.Normal, UnpackScaleNormal(detailSample, _DetailNormalStrength * detailMask));\n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * detailSample.z, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n\n\t\to.Alpha = c.a;\n\t}\n\n\n\n        \n            void ChainSurfaceFunction(inout LightingInputs l, ShaderData d)\n            {\n                   SurfaceFunction(l, d);\n                 // SurfaceFunction_Ext1(l, d);\n                 // SurfaceFunction_Ext2(l, d);\n                 // SurfaceFunction_Ext3(l, d);\n                 // SurfaceFunction_Ext4(l, d);\n                 // SurfaceFunction_Ext5(l, d);\n                 // SurfaceFunction_Ext6(l, d);\n                 // SurfaceFunction_Ext7(l, d);\n                 // SurfaceFunction_Ext8(l, d);\n                 // SurfaceFunction_Ext9(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraData d = (ExtraData)0;\n                 //  ModifyVertex(v, d);\n                 // ModifyVertex_Ext1(v, d);\n                 // ModifyVertex_Ext2(v, d);\n                 // ModifyVertex_Ext3(v, d);\n                 // ModifyVertex_Ext4(v, d);\n                 // ModifyVertex_Ext5(v, d);\n                 // ModifyVertex_Ext6(v, d);\n                 // ModifyVertex_Ext7(v, d);\n                 // ModifyVertex_Ext8(v, d);\n                 // ModifyVertex_Ext9(v, d);\n                 // v2p.extraData0 = d.extraData0;\n                 // v2p.extraData1 = d.extraData1;\n                 // v2p.extraData2 = d.extraData2;\n                 // v2p.extraData3 = d.extraData3;\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraData d = (ExtraData)0;\n               //  ModifyTessellatedVertex(v, d);\n               // ModifyTessellatedVertex_Ext1(v, d);\n               // ModifyTessellatedVertex_Ext2(v, d);\n               // ModifyTessellatedVertex_Ext3(v, d);\n               // ModifyTessellatedVertex_Ext4(v, d);\n               // ModifyTessellatedVertex_Ext5(v, d);\n               // ModifyTessellatedVertex_Ext6(v, d);\n               // ModifyTessellatedVertex_Ext7(v, d);\n               // ModifyTessellatedVertex_Ext8(v, d);\n               // ModifyTessellatedVertex_Ext9(v, d);\n               // v2p.extraData0 = d.extraData0;\n               // v2p.extraData1 = d.extraData1;\n               // v2p.extraData2 = d.extraData2;\n               // v2p.extraData3 = d.extraData3;\n            }\n\n\n\n         \n\n         ShaderData CreateShaderData(VertexToPixel i)\n         {\n            ShaderData d = (ShaderData)0;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = i.worldNormal;\n            d.worldSpaceTangent = i.worldTangent.xyz;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n            // d.texcoord3 = i.texcoord3;\n            // d.vertexColor = i.color;\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            // d.localSpacePosition = mul(unity_WorldToObject, i.worldPos);\n            // d.localSpaceNormal = mul(unity_WorldToObject, i.worldNormal);\n            // d.localSpaceTangent = mul(unity_WorldToObject, i.worldTangent.xyz);\n\n            // d.screenPos = i.screenPos;\n            // d.screenUV = i.screenPos.xy / i.screenPos.w;\n\n            // d.extraData0 = i.extraData0;\n            // d.extraData1 = i.extraData1;\n            // d.extraData2 = i.extraData2;\n            // d.extraData3 = i.extraData3;\n\n            return d;\n         }\n         \n\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n            UNITY_SETUP_INSTANCE_ID(v);\n            VertexToPixel o;\n            UNITY_INITIALIZE_OUTPUT(VertexToPixel,o);\n            UNITY_TRANSFER_INSTANCE_ID(v,o);\n            UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o);\n#endif\n\n            o.pos = UnityObjectToClipPos(v.vertex);\n             o.texcoord0 = v.texcoord0;\n            // o.texcoord1 = v.texcoord1;\n            // o.texcoord2 = v.texcoord2;\n            // o.texcoord3 = v.texcoord3;\n            // o.color = v.color;\n            // o.screenPos = ComputeScreenPos(o.pos);\n            o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n            o.worldNormal = UnityObjectToWorldNormal(v.normal);\n            o.worldTangent.xyz = UnityObjectToWorldDir(v.tangent.xyz);\n            fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n            float3 worldBinormal = cross(o.worldNormal, o.worldTangent.xyz) * tangentSign;\n            o.worldTangent.w = tangentSign;\n\n            float3 viewDirForLight = UnityWorldSpaceViewDir(o.worldPos);\n            #ifndef DIRLIGHTMAP_OFF\n               o.viewDir.x = dot(viewDirForLight, o.worldTangent.xyz);\n               o.viewDir.y = dot(viewDirForLight, worldBinormal);\n               o.viewDir.z = dot(viewDirForLight, o.worldNormal);\n            #endif\n            #ifdef DYNAMICLIGHTMAP_ON\n               o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n            #else\n               o.lmap.zw = 0;\n            #endif\n            #ifdef LIGHTMAP_ON\n               o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n               #ifdef DIRLIGHTMAP_OFF\n                  o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n                  o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n               #endif\n            #else\n               o.lmap.xy = 0;\n               #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n                  o.sh = 0;\n                  o.sh = ShadeSHPerVertex (o.worldNormal, o.sh);\n               #endif\n            #endif\n\n            return o;\n         }\n\n         \n\n         #ifdef LIGHTMAP_ON\n         float4 unity_LightmapFade;\n         #endif\n         fixed4 unity_Ambient;\n\n         \n\n         // fragment shader\n         void Frag (VertexToPixel IN,\n             out half4 outGBuffer0 : SV_Target0,\n             out half4 outGBuffer1 : SV_Target1,\n             out half4 outGBuffer2 : SV_Target2,\n             out half4 outEmission : SV_Target3\n         #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n             , out half4 outShadowMask : SV_Target4\n         #endif\n         )\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           // prepare and unpack data\n\n           #ifdef FOG_COMBINED_WITH_TSPACE\n             UNITY_EXTRACT_FOG_FROM_TSPACE(IN);\n           #elif defined (FOG_COMBINED_WITH_WORLD_POS)\n             UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);\n           #else\n             UNITY_EXTRACT_FOG(IN);\n           #endif\n\n\n           ShaderData d = CreateShaderData(IN);\n\n           LightingInputs l = (LightingInputs)0;\n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n\n\n           #ifndef USING_DIRECTIONAL_LIGHT\n             fixed3 lightDir = normalize(UnityWorldSpaceLightDir(d.worldSpacePosition));\n           #else\n             fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n           #endif\n           float3 worldViewDir = normalize(UnityWorldSpaceViewDir(d.worldSpacePosition));\n\n           #if _USESPECULAR\n              #ifdef UNITY_COMPILER_HLSL\n              SurfaceOutputStandardSpecular o = (SurfaceOutputStandardSpecular)0;\n              #else\n              SurfaceOutputStandardSpecular o;\n              #endif\n              o.Specular = l.Specular;\n           #else\n              #ifdef UNITY_COMPILER_HLSL\n              SurfaceOutputStandard o = (SurfaceOutputStandard)0;\n              #else\n              SurfaceOutputStandard o;\n              #endif\n              o.Metallic = l.Metallic;\n           #endif\n\n\n           o.Albedo = l.Albedo;\n           o.Normal = normalize(TangentToWorldSpace(d, l.Normal));\n           o.Occlusion = l.Occlusion;\n           o.Smoothness = l.Smoothness;\n           o.Alpha = l.Alpha;\n\n\n           half atten = 1;\n\n           // Setup lighting environment\n           UnityGI gi;\n           UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n           gi.indirect.diffuse = 0;\n           gi.indirect.specular = 0;\n           gi.light.color = 0;\n           gi.light.dir = half3(0,1,0);\n           // Call GI (lightmaps/SH/reflections) lighting function\n           UnityGIInput giInput;\n           UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n           giInput.light = gi.light;\n           giInput.worldPos = d.worldSpacePosition;\n           giInput.worldViewDir = worldViewDir;\n           giInput.atten = atten;\n           #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n             giInput.lightmapUV = IN.lmap;\n           #else\n             giInput.lightmapUV = 0.0;\n           #endif\n           #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n             giInput.ambient = IN.sh;\n           #else\n             giInput.ambient.rgb = 0.0;\n           #endif\n           giInput.probeHDR[0] = unity_SpecCube0_HDR;\n           giInput.probeHDR[1] = unity_SpecCube1_HDR;\n           #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n             giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending\n           #endif\n           #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n             giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n             giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n             giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n             giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n             giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n           #endif\n\n           #if _USESPECULAR\n              LightingStandardSpecular_GI(o, giInput, gi);\n\n              // call lighting function to output g-buffer\n              outEmission = LightingStandardSpecular_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n              #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n                outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);\n              #endif\n              #ifndef UNITY_HDR_ON\n              outEmission.rgb = exp2(-outEmission.rgb);\n              #endif\n           #else\n              LightingStandard_GI(o, giInput, gi);\n\n              // call lighting function to output g-buffer\n              outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n              #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n                outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, d.worldSpacePosition);\n              #endif\n              #ifndef UNITY_HDR_ON\n              outEmission.rgb = exp2(-outEmission.rgb);\n              #endif\n           #endif\n            \n           #if !defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT <= 4)\n             half4 outShadowMask = 0;\n           #endif\n\n           // FinalGBufferStandard(o, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n         }\n\n\n\n\n         ENDCG\n\n      }\n\n\n      \n\t   Pass {\n\t\t   Name \"ShadowCaster\"\n\t\t   Tags { \"LightMode\" = \"ShadowCaster\" }\n\t\t   ZWrite On ZTest LEqual\n\n         CGPROGRAM\n\n            #pragma vertex Vert\n   #pragma fragment Frag\n         // compile directives\n         #pragma target 3.0\n         #pragma multi_compile_instancing\n         #pragma skip_variants FOG_LINEAR FOG_EXP FOG_EXP2\n         #pragma multi_compile_shadowcaster\n         #include \"HLSLSupport.cginc\"\n         #define UNITY_INSTANCED_LOD_FADE\n         #define UNITY_INSTANCED_SH\n         #define UNITY_INSTANCED_LIGHTMAPSTS\n         #include \"UnityShaderVariables.cginc\"\n         #include \"UnityShaderUtilities.cginc\"\n\n         #include \"UnityCG.cginc\"\n         #include \"Lighting.cginc\"\n         #include \"UnityPBSLighting.cginc\"\n\n            #pragma shader_feature_local _ _MASKMAP\n   #pragma shader_feature_local _ _DETAIL\n   #pragma shader_feature_local _ _EMISSION\n\n   #define _STANDARD 1\n\n\n\n         // data across stages, stripped like the above.\n         struct VertexToPixel\n         {\n            V2F_SHADOW_CASTER;\n            float3 worldPos : TEXCOORD0;\n            float3 worldNormal : TEXCOORD1;\n            float4 worldTangent : TEXCOORD2;\n             float4 texcoord0 : TEXCCOORD3;\n            // float4 texcoord1 : TEXCCOORD4;\n            // float4 texcoord2 : TEXCCOORD5;\n            // float4 texcoord3 : TEXCCOORD6;\n            // float4 screenPos : TEXCOORD7;\n            // float4 color : COLOR;\n\n            // float4 extraData0 : TEXCOORD8;\n            // float4 extraData1 : TEXCOORD9;\n            // float4 extraData2 : TEXCOORD10;\n            // float4 extraData3 : TEXCOORD11;\n\n            UNITY_VERTEX_INPUT_INSTANCE_ID\n            UNITY_VERTEX_OUTPUT_STEREO\n         };\n\n         \n            \n            // data describing the user output of a pixel\n            struct LightingInputs\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half Alpha;\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half Anisotropy;\n               half iridescenceMask;\n               half iridescenceThickness;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n\n               float3x3 TBNMatrix;\n            };\n\n            struct VertexData\n            {\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n            \n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n\n               \n               // float4 extraData0 : TEXCOORD4;\n               // float4 extraData1 : TEXCOORD5;\n               // float4 extraData2 : TEXCOORD6;\n               // float4 extraData3 : TEXCOORD7;\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraData\n            {\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, p); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n            #endif\n\n\n            \n         \thalf4 _Tint;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half _EmissionStrength;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n\n\n         \n   half3 BlendDetailNormal(half3 n1, half3 n2)\n   {\n      return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n   }\n\n   // We share samplers with the albedo - which free's up more for stacking.\n\n   UNITY_DECLARE_TEX2D(_AlbedoMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_NormalMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_MaskMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_EmissionMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_DetailMap);\n\n\n\tvoid SurfaceFunction(inout LightingInputs o, ShaderData d)\n\t{\n      float2 uv = d.texcoord0.xy * _AlbedoMap_ST.xy + _AlbedoMap_ST.zw;\n\n      half4 c = UNITY_SAMPLE_TEX2D(_AlbedoMap, uv);\n      o.Albedo = c.rgb * _Tint.rgb;\n\t\to.Normal = UnpackScaleNormal(UNITY_SAMPLE_TEX2D_SAMPLER(_NormalMap, _AlbedoMap, uv), _NormalStrength);\n\n      half detailMask = 1;\n      #if _MASKMAP\n          // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = UNITY_SAMPLE_TEX2D_SAMPLER(_MaskMap, _AlbedoMap, uv);\n         o.Metallic = mask.r;\n         o.Occlusion = mask.g;\n         o.Smoothness = mask.a;\n         detailMask = mask.b;\n      #endif // separate maps\n\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap, _AlbedoMap, uv).rgb * _EmissionStrength;\n      #endif\n\n      #if defined(_DETAIL)\n         float2 detailUV = uv * _DetailMap_ST.xy + _DetailMap_ST.zw;\n         half4 detailSample = UNITY_SAMPLE_TEX2D_SAMPLER(_DetailMap, _AlbedoMap, detailUV);\n         o.Normal = BlendDetailNormal(o.Normal, UnpackScaleNormal(detailSample, _DetailNormalStrength * detailMask));\n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * detailSample.z, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n\n\t\to.Alpha = c.a;\n\t}\n\n\n\n        \n            void ChainSurfaceFunction(inout LightingInputs l, ShaderData d)\n            {\n                   SurfaceFunction(l, d);\n                 // SurfaceFunction_Ext1(l, d);\n                 // SurfaceFunction_Ext2(l, d);\n                 // SurfaceFunction_Ext3(l, d);\n                 // SurfaceFunction_Ext4(l, d);\n                 // SurfaceFunction_Ext5(l, d);\n                 // SurfaceFunction_Ext6(l, d);\n                 // SurfaceFunction_Ext7(l, d);\n                 // SurfaceFunction_Ext8(l, d);\n                 // SurfaceFunction_Ext9(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraData d = (ExtraData)0;\n                 //  ModifyVertex(v, d);\n                 // ModifyVertex_Ext1(v, d);\n                 // ModifyVertex_Ext2(v, d);\n                 // ModifyVertex_Ext3(v, d);\n                 // ModifyVertex_Ext4(v, d);\n                 // ModifyVertex_Ext5(v, d);\n                 // ModifyVertex_Ext6(v, d);\n                 // ModifyVertex_Ext7(v, d);\n                 // ModifyVertex_Ext8(v, d);\n                 // ModifyVertex_Ext9(v, d);\n                 // v2p.extraData0 = d.extraData0;\n                 // v2p.extraData1 = d.extraData1;\n                 // v2p.extraData2 = d.extraData2;\n                 // v2p.extraData3 = d.extraData3;\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraData d = (ExtraData)0;\n               //  ModifyTessellatedVertex(v, d);\n               // ModifyTessellatedVertex_Ext1(v, d);\n               // ModifyTessellatedVertex_Ext2(v, d);\n               // ModifyTessellatedVertex_Ext3(v, d);\n               // ModifyTessellatedVertex_Ext4(v, d);\n               // ModifyTessellatedVertex_Ext5(v, d);\n               // ModifyTessellatedVertex_Ext6(v, d);\n               // ModifyTessellatedVertex_Ext7(v, d);\n               // ModifyTessellatedVertex_Ext8(v, d);\n               // ModifyTessellatedVertex_Ext9(v, d);\n               // v2p.extraData0 = d.extraData0;\n               // v2p.extraData1 = d.extraData1;\n               // v2p.extraData2 = d.extraData2;\n               // v2p.extraData3 = d.extraData3;\n            }\n\n\n\n         \n\n         ShaderData CreateShaderData(VertexToPixel i)\n         {\n            ShaderData d = (ShaderData)0;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = i.worldNormal;\n            d.worldSpaceTangent = i.worldTangent.xyz;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n            // d.texcoord3 = i.texcoord3;\n            // d.vertexColor = i.color;\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            // d.localSpacePosition = mul(unity_WorldToObject, i.worldPos);\n            // d.localSpaceNormal = mul(unity_WorldToObject, i.worldNormal);\n            // d.localSpaceTangent = mul(unity_WorldToObject, i.worldTangent.xyz);\n\n            // d.screenPos = i.screenPos;\n            // d.screenUV = i.screenPos.xy / i.screenPos.w;\n\n            // d.extraData0 = i.extraData0;\n            // d.extraData1 = i.extraData1;\n            // d.extraData2 = i.extraData2;\n            // d.extraData3 = i.extraData3;\n\n            return d;\n         }\n         \n\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n            UNITY_SETUP_INSTANCE_ID(v);\n            VertexToPixel o;\n            UNITY_INITIALIZE_OUTPUT(VertexToPixel,o);\n            UNITY_TRANSFER_INSTANCE_ID(v,o);\n            UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n#if !_TESSELLATION_ON\n           // ModifyVertex(v);\n           // ModifyVertex_Ext1(v);\n           // ModifyVertex_Ext2(v);\n           // ModifyVertex_Ext3(v);\n           // ModifyVertex_Ext4(v);\n           // ModifyVertex_Ext5(v);\n           // ModifyVertex_Ext6(v);\n           // ModifyVertex_Ext7(v);\n           // ModifyVertex_Ext8(v);\n           // ModifyVertex_Ext9(v);\n#endif\n\n             o.texcoord0 = v.texcoord0;\n            // o.texcoord1 = v.texcoord1;\n            // o.texcoord2 = v.texcoord2;\n            // o.texcoord3 = v.texcoord3;\n            // o.color = v.color;\n            // o.screenPos = ComputeScreenPos(o.pos);\n            o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n            o.worldNormal = UnityObjectToWorldNormal(v.normal);\n            o.worldTangent.xyz = UnityObjectToWorldDir(v.tangent.xyz);\n            fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n            float3 worldBinormal = cross(o.worldNormal, o.worldTangent.xyz) * tangentSign;\n            o.worldTangent.w = tangentSign;\n\n            TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)\n            return o;\n         }\n\n         \n\n         // fragment shader\n         fixed4 Frag (VertexToPixel IN) : SV_Target\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           // prepare and unpack data\n\n           #ifdef FOG_COMBINED_WITH_TSPACE\n             UNITY_EXTRACT_FOG_FROM_TSPACE(IN);\n           #elif defined (FOG_COMBINED_WITH_WORLD_POS)\n             UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);\n           #else\n             UNITY_EXTRACT_FOG(IN);\n           #endif\n\n           #ifndef USING_DIRECTIONAL_LIGHT\n             fixed3 lightDir = normalize(UnityWorldSpaceLightDir(IN.worldPos));\n           #else\n             fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n           #endif\n\n           ShaderData d = CreateShaderData(IN);\n\n           LightingInputs l = (LightingInputs)0;\n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n           SHADOW_CASTER_FRAGMENT(IN)\n         }\n\n\n         ENDCG\n\n      }\n\n      \n\t   // ---- meta information extraction pass:\n\t   Pass\n      {\n\t\t   Name \"Meta\"\n\t\t   Tags { \"LightMode\" = \"Meta\" }\n\t\t   Cull Off\n\n         CGPROGRAM\n\n            #pragma vertex Vert\n   #pragma fragment Frag\n\n         // compile directives\n         #pragma target 3.0\n         #pragma multi_compile_instancing\n         #pragma skip_variants FOG_LINEAR FOG_EXP FOG_EXP2\n         #pragma shader_feature EDITOR_VISUALIZATION\n\n         #include \"HLSLSupport.cginc\"\n         #define UNITY_INSTANCED_LOD_FADE\n         #define UNITY_INSTANCED_SH\n         #define UNITY_INSTANCED_LIGHTMAPSTS\n         #include \"UnityShaderVariables.cginc\"\n         #include \"UnityShaderUtilities.cginc\"\n\n         #include \"UnityCG.cginc\"\n         #include \"Lighting.cginc\"\n         #include \"UnityPBSLighting.cginc\"\n         #include \"UnityMetaPass.cginc\"\n\n            #pragma shader_feature_local _ _MASKMAP\n   #pragma shader_feature_local _ _DETAIL\n   #pragma shader_feature_local _ _EMISSION\n\n   #define _STANDARD 1\n\n\n         // data across stages, stripped like the above.\n         struct VertexToPixel\n         {\n            UNITY_POSITION(pos);\n            float3 worldPos : TEXCOORD0;\n            float3 worldNormal : TEXCOORD1;\n            float4 worldTangent : TEXCOORD2;\n             float4 texcoord0 : TEXCCOORD3;\n            // float4 texcoord1 : TEXCCOORD4;\n            // float4 texcoord2 : TEXCCOORD5;\n            // float4 texcoord3 : TEXCCOORD6;\n            // float4 screenPos : TEXCOORD7;\n            // float4 color : COLOR;\n            #ifdef EDITOR_VISUALIZATION\n              float2 vizUV : TEXCOORD8;\n              float4 lightCoord : TEXCOORD9;\n            #endif\n\n            // float4 extraData0 : TEXCOORD10;\n            // float4 extraData1 : TEXCOORD11;\n            // float4 extraData2 : TEXCOORD12;\n            // float4 extraData3 : TEXCOORD13;\n\n\n            UNITY_VERTEX_INPUT_INSTANCE_ID\n            UNITY_VERTEX_OUTPUT_STEREO\n         };\n\n         \n            \n            // data describing the user output of a pixel\n            struct LightingInputs\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half Alpha;\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half Anisotropy;\n               half iridescenceMask;\n               half iridescenceThickness;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n\n               float3x3 TBNMatrix;\n            };\n\n            struct VertexData\n            {\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n            \n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n\n               \n               // float4 extraData0 : TEXCOORD4;\n               // float4 extraData1 : TEXCOORD5;\n               // float4 extraData2 : TEXCOORD6;\n               // float4 extraData3 : TEXCOORD7;\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraData\n            {\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, p); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n            #endif\n\n\n            \n         \thalf4 _Tint;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half _EmissionStrength;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n\n\n         \n   half3 BlendDetailNormal(half3 n1, half3 n2)\n   {\n      return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n   }\n\n   // We share samplers with the albedo - which free's up more for stacking.\n\n   UNITY_DECLARE_TEX2D(_AlbedoMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_NormalMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_MaskMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_EmissionMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_DetailMap);\n\n\n\tvoid SurfaceFunction(inout LightingInputs o, ShaderData d)\n\t{\n      float2 uv = d.texcoord0.xy * _AlbedoMap_ST.xy + _AlbedoMap_ST.zw;\n\n      half4 c = UNITY_SAMPLE_TEX2D(_AlbedoMap, uv);\n      o.Albedo = c.rgb * _Tint.rgb;\n\t\to.Normal = UnpackScaleNormal(UNITY_SAMPLE_TEX2D_SAMPLER(_NormalMap, _AlbedoMap, uv), _NormalStrength);\n\n      half detailMask = 1;\n      #if _MASKMAP\n          // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = UNITY_SAMPLE_TEX2D_SAMPLER(_MaskMap, _AlbedoMap, uv);\n         o.Metallic = mask.r;\n         o.Occlusion = mask.g;\n         o.Smoothness = mask.a;\n         detailMask = mask.b;\n      #endif // separate maps\n\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap, _AlbedoMap, uv).rgb * _EmissionStrength;\n      #endif\n\n      #if defined(_DETAIL)\n         float2 detailUV = uv * _DetailMap_ST.xy + _DetailMap_ST.zw;\n         half4 detailSample = UNITY_SAMPLE_TEX2D_SAMPLER(_DetailMap, _AlbedoMap, detailUV);\n         o.Normal = BlendDetailNormal(o.Normal, UnpackScaleNormal(detailSample, _DetailNormalStrength * detailMask));\n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * detailSample.z, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n\n\t\to.Alpha = c.a;\n\t}\n\n\n\n        \n            void ChainSurfaceFunction(inout LightingInputs l, ShaderData d)\n            {\n                   SurfaceFunction(l, d);\n                 // SurfaceFunction_Ext1(l, d);\n                 // SurfaceFunction_Ext2(l, d);\n                 // SurfaceFunction_Ext3(l, d);\n                 // SurfaceFunction_Ext4(l, d);\n                 // SurfaceFunction_Ext5(l, d);\n                 // SurfaceFunction_Ext6(l, d);\n                 // SurfaceFunction_Ext7(l, d);\n                 // SurfaceFunction_Ext8(l, d);\n                 // SurfaceFunction_Ext9(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraData d = (ExtraData)0;\n                 //  ModifyVertex(v, d);\n                 // ModifyVertex_Ext1(v, d);\n                 // ModifyVertex_Ext2(v, d);\n                 // ModifyVertex_Ext3(v, d);\n                 // ModifyVertex_Ext4(v, d);\n                 // ModifyVertex_Ext5(v, d);\n                 // ModifyVertex_Ext6(v, d);\n                 // ModifyVertex_Ext7(v, d);\n                 // ModifyVertex_Ext8(v, d);\n                 // ModifyVertex_Ext9(v, d);\n                 // v2p.extraData0 = d.extraData0;\n                 // v2p.extraData1 = d.extraData1;\n                 // v2p.extraData2 = d.extraData2;\n                 // v2p.extraData3 = d.extraData3;\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraData d = (ExtraData)0;\n               //  ModifyTessellatedVertex(v, d);\n               // ModifyTessellatedVertex_Ext1(v, d);\n               // ModifyTessellatedVertex_Ext2(v, d);\n               // ModifyTessellatedVertex_Ext3(v, d);\n               // ModifyTessellatedVertex_Ext4(v, d);\n               // ModifyTessellatedVertex_Ext5(v, d);\n               // ModifyTessellatedVertex_Ext6(v, d);\n               // ModifyTessellatedVertex_Ext7(v, d);\n               // ModifyTessellatedVertex_Ext8(v, d);\n               // ModifyTessellatedVertex_Ext9(v, d);\n               // v2p.extraData0 = d.extraData0;\n               // v2p.extraData1 = d.extraData1;\n               // v2p.extraData2 = d.extraData2;\n               // v2p.extraData3 = d.extraData3;\n            }\n\n\n\n         \n\n         ShaderData CreateShaderData(VertexToPixel i)\n         {\n            ShaderData d = (ShaderData)0;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = i.worldNormal;\n            d.worldSpaceTangent = i.worldTangent.xyz;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n            // d.texcoord3 = i.texcoord3;\n            // d.vertexColor = i.color;\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            // d.localSpacePosition = mul(unity_WorldToObject, i.worldPos);\n            // d.localSpaceNormal = mul(unity_WorldToObject, i.worldNormal);\n            // d.localSpaceTangent = mul(unity_WorldToObject, i.worldTangent.xyz);\n\n            // d.screenPos = i.screenPos;\n            // d.screenUV = i.screenPos.xy / i.screenPos.w;\n\n            // d.extraData0 = i.extraData0;\n            // d.extraData1 = i.extraData1;\n            // d.extraData2 = i.extraData2;\n            // d.extraData3 = i.extraData3;\n\n            return d;\n         }\n         \n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n            UNITY_SETUP_INSTANCE_ID(v);\n            VertexToPixel o;\n            UNITY_INITIALIZE_OUTPUT(VertexToPixel,o);\n            UNITY_TRANSFER_INSTANCE_ID(v,o);\n            UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o);\n#endif\n\n            o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n            #ifdef EDITOR_VISUALIZATION\n               o.vizUV = 0;\n               o.lightCoord = 0;\n               if (unity_VisualizationMode == EDITORVIZ_TEXTURE)\n                  o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);\n               else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)\n               {\n                  o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n                  o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));\n               }\n            #endif\n\n\n             o.texcoord0 = v.texcoord0;\n            // o.texcoord1 = v.texcoord1;\n            // o.texcoord2 = v.texcoord2;\n            // o.texcoord3 = v.texcoord3;\n            // o.color = v.color;\n            // o.screenPos = ComputeScreenPos(o.pos);\n            o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n            o.worldNormal = UnityObjectToWorldNormal(v.normal);\n            o.worldTangent.xyz = UnityObjectToWorldDir(v.tangent.xyz);\n            fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;\n            o.worldTangent.w = tangentSign;\n\n            return o;\n         }\n\n         \n\n         // fragment shader\n         fixed4 Frag (VertexToPixel IN) : SV_Target\n         {\n            UNITY_SETUP_INSTANCE_ID(IN);\n\n            #ifdef FOG_COMBINED_WITH_TSPACE\n               UNITY_EXTRACT_FOG_FROM_TSPACE(IN);\n            #elif defined (FOG_COMBINED_WITH_WORLD_POS)\n               UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);\n            #else\n               UNITY_EXTRACT_FOG(IN);\n            #endif\n\n            ShaderData d = CreateShaderData(IN);\n\n            LightingInputs l = (LightingInputs)0;\n\n            l.Albedo = half3(0.5, 0.5, 0.5);\n            l.Normal = float3(0,0,1);\n            l.Occlusion = 1;\n            l.Alpha = 1;\n\n            \n            ChainSurfaceFunction(l, d);\n\n            UnityMetaInput metaIN;\n            UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);\n            metaIN.Albedo = l.Albedo;\n            metaIN.Emission = l.Emission;\n\n            #if _USESPECULAR\n               metaIN.SpecularColor = l.Specular;\n            #endif\n\n            #ifdef EDITOR_VISUALIZATION\n              metaIN.VizUV = IN.vizUV;\n              metaIN.LightCoord = IN.lightCoord;\n            #endif\n            return UnityMetaFragment(metaIN);\n         }\n         ENDCG\n\n      }\n\n\n   }\n   \n   \n}\n"},{"srpTarget":2,"UnityVersionMin":20194,"UnityVersionMax":30000,"shader":{"fileID":4800000,"guid":"b0e6d750f088a4579aedd48618d2473d","type":3},"shaderSrc":"Shader \"BetterShaders/Standard\"\n{\n   Properties\n   {\n         _AlbedoMap(\"Albedo\", 2D) = \"white\" {}\n\t_Tint (\"Tint\", Color) = (1, 1, 1, 1)\n   \n   [Normal][NoScaleOffset]_NormalMap(\"Normal\", 2D) = \"bump\" {}\n   _NormalStrength(\"Normal Strength\", Range(0,2)) = 1\n\n   [Toggle(_MASKMAP)]\n   _UseMaskMap (\"Use Mask Map\", Float) = 0\n   [NoScaleOffset]_MaskMap(\"Mask Map\", 2D) = \"black\" {}\n\n   [Toggle(_EMISSION)]\n   _UseEmission (\"Use Emission Map\", Float) = 0\n   [NoScaleOffset]_EmissionMap(\"Emission Map\", 2D) = \"black\" {}\n   _EmissionStrength(\"Emission Strength\", Range(0, 4)) = 1\n\n   [Toggle(_DETAIL)]\n   _UseDetail(\"Use Detail Map\", Float) = 0\n   _DetailMap(\"Detail Map\", 2D) = \"bump\" {}\n   _DetailAlbedoStrength(\"Detail Albedo Strength\", Range(0, 2)) = 1\n   _DetailNormalStrength(\"Detail Normal Strength\", Range(0, 2)) = 1\n   _DetailSmoothnessStrength(\"Detail Smoothness Strength\", Range(0, 2)) = 1\n\n\n\n      [HideInInspector] _StencilRef(\"Vector1 \", Int) = 0\n      [HideInInspector] _StencilWriteMask(\"Vector1 \", Int) = 3\n      [HideInInspector] _StencilRefDepth(\"Vector1 \", Int) = 0\n      [HideInInspector] _StencilWriteMaskDepth(\"Vector1 \", Int) = 32\n      [HideInInspector] _StencilRefMV(\"Vector1 \", Int) = 128\n      [HideInInspector] _StencilWriteMaskMV(\"Vector1 \", Int) = 128\n      [HideInInspector] _StencilRefDistortionVec(\"Vector1 \", Int) = 64\n      [HideInInspector] _StencilWriteMaskDistortionVec(\"Vector1 \", Int) = 64\n      [HideInInspector] _StencilWriteMaskGBuffer(\"Vector1 \", Int) = 3\n      [HideInInspector] _StencilRefGBuffer(\"Vector1 \", Int) = 2\n      [HideInInspector] _ZTestGBuffer(\"Vector1 \", Int) = 4\n      [HideInInspector] [ToggleUI] _RequireSplitLighting(\"Boolean\", Float) = 0\n      [HideInInspector] [ToggleUI] _ReceivesSSR(\"Boolean\", Float) = 1\n      [HideInInspector] _SurfaceType(\"Vector1 \", Float) = 0\n      [HideInInspector] [ToggleUI] _ZWrite(\"Boolean\", Float) = 0\n      [HideInInspector] _CullMode(\"Vector1 \", Float) = 2\n      [HideInInspector] _TransparentSortPriority(\"Vector1 \", Int) = 0\n      [HideInInspector] _CullModeForward(\"Vector1 \", Float) = 2\n      [HideInInspector] [Enum(Front, 1, Back, 2)] _TransparentCullMode(\"Vector1\", Float) = 2\n      [HideInInspector] _ZTestDepthEqualForOpaque(\"Vector1 \", Int) = 4\n      [HideInInspector] [Enum(UnityEngine.Rendering.CompareFunction)] _ZTestTransparent(\"Vector1\", Float) = 4\n      [HideInInspector] [ToggleUI] _TransparentBackfaceEnable(\"Boolean\", Float) = 0\n      [HideInInspector] [ToggleUI] _AlphaCutoffEnable(\"Boolean\", Float) = 0\n      [HideInInspector] [ToggleUI] _UseShadowThreshold(\"Boolean\", Float) = 0\n      [HideInInspector] [ToggleUI] _DoubleSidedEnable(\"Boolean\", Float) = 0\n      [HideInInspector] [Enum(Flip, 0, Mirror, 1, None, 2)] _DoubleSidedNormalMode(\"Vector1\", Float) = 2\n      [HideInInspector] _DoubleSidedConstants(\"Vector4\", Vector) = (1,1,-1,0)\n\n   }\n   SubShader\n   {\n      Tags { \"RenderPipeline\"=\"HDRenderPipeline\" \"RenderType\" = \"HDLitShader\" \"Queue\" = \"Geometry\" }\n\n      Pass\n        {\n            // based on HDLitPass.template\n            Name \"ShadowCaster\"\n            Tags { \"LightMode\" = \"ShadowCaster\" }\n        \n            //-------------------------------------------------------------------------------------\n            // Render Modes (Blend, Cull, ZTest, Stencil, etc)\n            //-------------------------------------------------------------------------------------\n            \n            Cull[_CullMode]\n\n            ZClip [_ZClip]\n            ZWrite On\n            ZTest LEqual\n\n            ColorMask 0\n        \n        \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 ps4 xboxone vulkan metal switch\n            //#pragma enable_d3d11_debug_symbols\n        \n            #pragma multi_compile_instancing\n\n            #pragma multi_compile_local _ _ALPHATEST_ON\n\n\n            //#pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _DOUBLESIDED_ON\n            //#pragma shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n        \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            // #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n        \n               #pragma shader_feature_local _ _MASKMAP\n   #pragma shader_feature_local _ _DETAIL\n   #pragma shader_feature_local _ _EMISSION\n\n   #define _HDRP 1\n\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n            //-------------------------------------------------------------------------------------\n            // Defines\n            //-------------------------------------------------------------------------------------\n            #define SHADERPASS SHADERPASS_SHADOWS\n            #define RAYTRACING_SHADER_GRAPH_HIGH\n\n        \n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler_##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler_##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler_##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler_##samp, coord)\n\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      half3 UnpackNormal(half4 packednormal)\n      {\n         half3 normal;\n         normal.xy = packednormal.wy * 2 - 1;\n         normal.z = sqrt(1 - normal.x*normal.x - normal.y * normal.y);\n         return normal;\n      }\n\n      half3 UnpackScaleNormal(half4 packednormal, half bumpScale)\n      {\n\t     #if defined(UNITY_NO_DXT5nm)\n\t        return packednormal.xyz * 2 - 1;\n\t     #else\n\t\t     half3 normal;\n\t\t     normal.xy = (packednormal.wy * 2 - 1);\n\t        #if (SHADER_TARGET >= 30)\n\t\t        normal.xy *= bumpScale;\n\t\t     #endif\n\t\t     normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n\t        return normal;\n\t     #endif\n      }\t\n\n\n// HDRP Adapter stuff\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n            #define OUTPUT_SPLIT_LIGHTING\n            #endif\n        \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n        \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n        \n            // define FragInputs structure\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n        \n\n    // We need isFontFace when using double sided\n        #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)\n            #define VARYINGS_NEED_CULLFACE\n        #endif\n        \n\n        \n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n        #ifdef DEBUG_DISPLAY\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n        #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n        \n        #if (SHADERPASS == SHADERPASS_FORWARD)\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n        \n            #define HAS_LIGHTLOOP\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n        #else\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n        #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n        \n            // Used by SceneSelectionPass\n            int _ObjectId;\n            int _PassValue;\n        \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCCOORD3;\n               float4 texcoord1 : TEXCCOORD4;\n               float4 texcoord2 : TEXCCOORD5;\n               // float4 texcoord3 : TEXCCOORD6;\n               // float4 screenPos : TEXCOORD7;\n               // float4 color : COLOR;\n\n               // float4 extraData0 : TEXCOORD8;\n               // float4 extraData1 : TEXCOORD9;\n               // float4 extraData2 : TEXCOORD10;\n               // float4 extraData3 : TEXCOORD11;\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n            };\n      \n  \n            \n            \n            // data describing the user output of a pixel\n            struct LightingInputs\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half Alpha;\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half Anisotropy;\n               half iridescenceMask;\n               half iridescenceThickness;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n\n               float3x3 TBNMatrix;\n            };\n\n            struct VertexData\n            {\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n            \n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n\n               \n               // float4 extraData0 : TEXCOORD4;\n               // float4 extraData1 : TEXCOORD5;\n               // float4 extraData2 : TEXCOORD6;\n               // float4 extraData3 : TEXCOORD7;\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraData\n            {\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), p); };\n               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), p); };\n               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }\n               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n\n               float _StencilRef;\n               float _StencilWriteMask;\n               float _StencilRefDepth;\n               float _StencilWriteMaskDepth;\n               float _StencilRefMV;\n               float _StencilWriteMaskMV;\n               float _StencilRefDistortionVec;\n               float _StencilWriteMaskDistortionVec;\n               float _StencilWriteMaskGBuffer;\n               float _StencilRefGBuffer;\n               float _ZTestGBuffer;\n               float _RequireSplitLighting;\n               float _ReceivesSSR;\n               float _ZWrite;\n               float _CullMode;\n               float _TransparentSortPriority;\n               float _CullModeForward;\n               float _TransparentCullMode;\n               float _ZTestDepthEqualForOpaque;\n               float _ZTestTransparent;\n               float _TransparentBackfaceEnable;\n               float _AlphaCutoffEnable;\n               float _UseShadowThreshold;\n               float _DoubleSidedEnable;\n               float _DoubleSidedNormalMode;\n               float4 _DoubleSidedConstants;\n\n               \thalf4 _Tint;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half _EmissionStrength;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n\n\n            CBUFFER_END\n\n            \n   half3 BlendDetailNormal(half3 n1, half3 n2)\n   {\n      return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n   }\n\n   // We share samplers with the albedo - which free's up more for stacking.\n\n   UNITY_DECLARE_TEX2D(_AlbedoMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_NormalMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_MaskMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_EmissionMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_DetailMap);\n\n\n\tvoid SurfaceFunction(inout LightingInputs o, ShaderData d)\n\t{\n      float2 uv = d.texcoord0.xy * _AlbedoMap_ST.xy + _AlbedoMap_ST.zw;\n\n      half4 c = UNITY_SAMPLE_TEX2D(_AlbedoMap, uv);\n      o.Albedo = c.rgb * _Tint.rgb;\n\t\to.Normal = UnpackScaleNormal(UNITY_SAMPLE_TEX2D_SAMPLER(_NormalMap, _AlbedoMap, uv), _NormalStrength);\n\n      half detailMask = 1;\n      #if _MASKMAP\n          // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = UNITY_SAMPLE_TEX2D_SAMPLER(_MaskMap, _AlbedoMap, uv);\n         o.Metallic = mask.r;\n         o.Occlusion = mask.g;\n         o.Smoothness = mask.a;\n         detailMask = mask.b;\n      #endif // separate maps\n\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap, _AlbedoMap, uv).rgb * _EmissionStrength;\n      #endif\n\n      #if defined(_DETAIL)\n         float2 detailUV = uv * _DetailMap_ST.xy + _DetailMap_ST.zw;\n         half4 detailSample = UNITY_SAMPLE_TEX2D_SAMPLER(_DetailMap, _AlbedoMap, detailUV);\n         o.Normal = BlendDetailNormal(o.Normal, UnpackScaleNormal(detailSample, _DetailNormalStrength * detailMask));\n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * detailSample.z, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n\n\t\to.Alpha = c.a;\n\t}\n\n\n\n        \n            void ChainSurfaceFunction(inout LightingInputs l, ShaderData d)\n            {\n                   SurfaceFunction(l, d);\n                 // SurfaceFunction_Ext1(l, d);\n                 // SurfaceFunction_Ext2(l, d);\n                 // SurfaceFunction_Ext3(l, d);\n                 // SurfaceFunction_Ext4(l, d);\n                 // SurfaceFunction_Ext5(l, d);\n                 // SurfaceFunction_Ext6(l, d);\n                 // SurfaceFunction_Ext7(l, d);\n                 // SurfaceFunction_Ext8(l, d);\n                 // SurfaceFunction_Ext9(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraData d = (ExtraData)0;\n                 //  ModifyVertex(v, d);\n                 // ModifyVertex_Ext1(v, d);\n                 // ModifyVertex_Ext2(v, d);\n                 // ModifyVertex_Ext3(v, d);\n                 // ModifyVertex_Ext4(v, d);\n                 // ModifyVertex_Ext5(v, d);\n                 // ModifyVertex_Ext6(v, d);\n                 // ModifyVertex_Ext7(v, d);\n                 // ModifyVertex_Ext8(v, d);\n                 // ModifyVertex_Ext9(v, d);\n                 // v2p.extraData0 = d.extraData0;\n                 // v2p.extraData1 = d.extraData1;\n                 // v2p.extraData2 = d.extraData2;\n                 // v2p.extraData3 = d.extraData3;\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraData d = (ExtraData)0;\n               //  ModifyTessellatedVertex(v, d);\n               // ModifyTessellatedVertex_Ext1(v, d);\n               // ModifyTessellatedVertex_Ext2(v, d);\n               // ModifyTessellatedVertex_Ext3(v, d);\n               // ModifyTessellatedVertex_Ext4(v, d);\n               // ModifyTessellatedVertex_Ext5(v, d);\n               // ModifyTessellatedVertex_Ext6(v, d);\n               // ModifyTessellatedVertex_Ext7(v, d);\n               // ModifyTessellatedVertex_Ext8(v, d);\n               // ModifyTessellatedVertex_Ext9(v, d);\n               // v2p.extraData0 = d.extraData0;\n               // v2p.extraData1 = d.extraData1;\n               // v2p.extraData2 = d.extraData2;\n               // v2p.extraData3 = d.extraData3;\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i)\n         {\n            ShaderData d = (ShaderData)0;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = i.worldNormal;\n            d.worldSpaceTangent = i.worldTangent.xyz;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n            // d.texcoord3 = i.texcoord3;\n            // d.vertexColor = i.color;\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            // d.localSpacePosition = mul(GetWorldToObjectMatrix(), i.worldPos);\n            // d.localSpaceNormal = mul(GetWorldToObjectMatrix(), i.worldNormal);\n            // d.localSpaceTangent = mul(GetWorldToObjectMatrix(), i.worldTangent.xyz);\n\n            // d.screenPos = i.screenPos;\n            // d.screenUV = i.screenPos.xy / i.screenPos.w;\n\n            // d.extraData0 = i.extraData0;\n            // d.extraData1 = i.extraData1;\n            // d.extraData2 = i.extraData2;\n            // d.extraData3 = i.extraData3;\n\n            return d;\n         }\n         \n\n            \n\nstruct VaryingsToPS\n{\n   VertexToPixel vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      VaryingsPassToPS vpass;\n   #endif\n};\n\nstruct PackedVaryingsToPS\n{\n   #ifdef VARYINGS_NEED_PASS\n      PackedVaryingsPassToPS vpass;\n   #endif\n   VertexToPixel vmesh;\n\n   UNITY_VERTEX_OUTPUT_STEREO\n};\n\nPackedVaryingsToPS PackVaryingsToPS(VaryingsToPS input)\n{\n   PackedVaryingsToPS output = (PackedVaryingsToPS)0;\n   output.vmesh = input.vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      output.vpass = PackVaryingsPassToPS(input.vpass);\n   #endif\n\n   UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n   return output;\n}\n\n\n\n\nVertexToPixel VertMesh(VertexData input)\n{\n    VertexToPixel output = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(input);\n    UNITY_TRANSFER_INSTANCE_ID(input, output);\n\n    \n    ChainModifyVertex(input, output);\n\n\n    // This return the camera relative position (if enable)\n    float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n    float3 normalWS = TransformObjectToWorldNormal(input.normal);\n    float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n    output.worldPos = positionRWS;\n    output.pos = TransformWorldToHClip(positionRWS);\n    output.worldNormal = normalWS;\n    output.worldTangent = tangentWS;\n\n\n    output.texcoord0 = input.texcoord0;\n    output.texcoord1 = input.texcoord1;\n    output.texcoord2 = input.texcoord2;\n    // output.texcoord3 = input.texcoord3;\n    // output.color = input.color;\n\n    return output;\n}\n\n\n#if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\nvoid MeshDecalsPositionZBias(inout VaryingsToPS input)\n{\n#if defined(UNITY_REVERSED_Z)\n    input.vmesh.pos.z -= _DecalMeshDepthBias;\n#else\n    input.vmesh.pos.z += _DecalMeshDepthBias;\n#endif\n}\n#endif\n\n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n// This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\nfloat unity_OneOverOutputBoost;\nfloat unity_MaxOutputValue;\n\nCBUFFER_START(UnityMetaPass)\n// x = use uv1 as raster position\n// y = use uv2 as raster position\nbool4 unity_MetaVertexControl;\n\n// x = return albedo\n// y = return normal\nbool4 unity_MetaFragmentControl;\nCBUFFER_END\n\nPackedVaryingsToPS Vert(VertexData inputMesh)\n{\n    VaryingsToPS output = (VaryingsToPS)0;\n    output.vmesh = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(inputMesh);\n    UNITY_TRANSFER_INSTANCE_ID(inputMesh, output.vmesh);\n\n    // Output UV coordinate in vertex shader\n    float2 uv = float2(0.0, 0.0);\n\n    if (unity_MetaVertexControl.x)\n    {\n        uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n    }\n    else if (unity_MetaVertexControl.y)\n    {\n        uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n    }\n\n    // OpenGL right now needs to actually use the incoming vertex position\n    // so we create a fake dependency on it here that haven't any impact.\n    output.vmesh.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n#ifdef VARYINGS_NEED_POSITION_WS\n    output.vmesh.worldPos = TransformObjectToWorld(inputMesh.vertex);\n#endif\n\n#ifdef VARYINGS_NEED_TANGENT_TO_WORLD\n    // Normal is required for triplanar mapping\n    output.vmesh.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n    // Not required but assign to silent compiler warning\n    output.vmesh.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n#endif\n\n    output.vmesh.texcoord0 = inputMesh.texcoord0;\n    output.vmesh.texcoord1 = inputMesh.texcoord1;\n    output.vmesh.texcoord2 = inputMesh.texcoord2;\n    // output.vmesh.texCoord3 = inputMesh.texcoord3;\n    // output.vmesh.color = inputMesh.color;\n\n    return PackVaryingsToPS(output);\n}\n#else\n\nPackedVaryingsToPS Vert(VertexData inputMesh)\n{\n    VaryingsToPS varyingsType;\n    varyingsType.vmesh = VertMesh(inputMesh);\n    #if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\n       MeshDecalsPositionZBias(varyingsType);\n    #endif\n    return PackVaryingsToPS(varyingsType);\n}\n\n#endif\n\n\n\n            \n\n            \n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n            \n                    output.positionRWS = input.worldPos;\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n                    //output.color = input.color;\n                    //#if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                    //output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                    //#elif SHADER_STAGE_FRAGMENT\n                    // output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                    //#endif // SHADER_STAGE_FRAGMENT\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout LightingInputs surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n        \n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n        \n           #ifdef _HAS_REFRACTION\n                   if (_EnableSSRefraction)\n                   {\n                       // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                       // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                       // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n        \n                       surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                       surfaceDescription.Alpha = 1.0;\n                   }\n                   else\n                   {\n                       surfaceData.ior = 1.0;\n                       surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                       surfaceData.atDistance = 1.0;\n                       surfaceData.transmittanceMask = 0.0;\n                       surfaceDescription.Alpha = 1.0;\n                   }\n           #else\n                   surfaceData.ior = 1.0;\n                   surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                   surfaceData.atDistance = 1.0;\n                   surfaceData.transmittanceMask = 0.0;\n           #endif\n                \n                   // These static material feature allow compile time optimization\n                   surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n           #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n           #endif\n           #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n           #endif\n           #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n           #endif\n                   // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n        \n           #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n           #endif\n           #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n           #endif\n        \n           #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                   // Require to have setup baseColor\n                   // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                   surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n           #endif\n        \n           #ifdef _DOUBLESIDED_ON\n               float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n           #else\n               float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n           #endif\n        \n                   // tangent-space normal\n                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                   normalTS = surfaceDescription.Normal;\n        \n                   // compute world space normal\n                   GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n        \n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                   // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent, fragInputs.tangentToWorld);\n        \n           #if HAVE_DECALS\n                   if (_EnableDecals)\n                   {\n                       #if VERSION_GREATER_EQUAL(10,2)\n                          DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput,  surfaceData.geomNormalWS, surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData,  surfaceData.geomNormalWS, surfaceData);\n                       #else\n                          DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                       #endif\n                   }\n           #endif\n        \n                   bentNormalWS = surfaceData.normalWS;\n                   // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n        \n                   surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n        \n        \n                   // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                   // If user provide bent normal then we process a better term\n           #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                   // Just use the value passed through via the slot (not active otherwise)\n           #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                   // If we have bent normal and ambient occlusion, process a specular occlusion\n                   surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n           #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                   surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n           #endif\n        \n           #ifdef _ENABLE_GEOMETRIC_SPECULAR_AA\n                   surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n           #endif\n        \n           #ifdef DEBUG_DISPLAY\n                   if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                   {\n                       // TODO: need to update mip info\n                       surfaceData.metallic = 0;\n                   }\n        \n                   // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                   // as it can modify attribute use for static lighting\n                   ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n           #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout LightingInputs l, inout ShaderData d)\n               {\n                 #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                     uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to _ScreenSize values\n                     LODDitheringTransition(fadeMaskSeed, unity_LODFade.x);\n                 #endif\n        \n                 #ifdef _DOUBLESIDED_ON\n                     float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                 #else\n                     float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                 #endif\n        \n                 ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n\n                 d = CreateShaderData(m2ps);\n\n                 l = (LightingInputs)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n\n                 ChainSurfaceFunction(l, d);\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n        \n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 builtinData.emissiveColor = l.Emission;\n        \n        \n                 #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     //builtinData.distortion = surfaceDescription.Distortion;\n                     //builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                     builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                 #else\n                     builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                 #endif\n        \n                   PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n               }\n        \n\n\n              void Frag(  PackedVaryingsToPS packedInput\n                          #ifdef WRITE_NORMAL_BUFFER\n                          , out float4 outNormalBuffer : SV_Target0\n                              #ifdef WRITE_MSAA_DEPTH\n                              , out float1 depthColor : SV_Target1\n                              #endif\n                          #elif defined(WRITE_MSAA_DEPTH) // When only WRITE_MSAA_DEPTH is define and not WRITE_NORMAL_BUFFER it mean we are Unlit and only need depth, but we still have normal buffer binded\n                          , out float4 outNormalBuffer : SV_Target0\n                          , out float1 depthColor : SV_Target1\n                          #elif defined(SCENESELECTIONPASS)\n                          , out float4 outColor : SV_Target0\n                          #endif\n\n                          #ifdef _DEPTHOFFSET_ON\n                          , out float outputDepth : SV_Depth\n                          #endif\n                      )\n              {\n                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(packedInput);\n                  FragInputs input = BuildFragInputs(packedInput.vmesh);\n\n                  // input.positionSS is SV_Position\n                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n                  #ifdef VARYINGS_NEED_POSITION_WS\n                     float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n                  #else\n                     // Unused\n                     float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0\n                  #endif\n\n                  SurfaceData surfaceData;\n                  BuiltinData builtinData;\n                  LightingInputs l;\n                  ShaderData d;\n                  GetSurfaceAndBuiltinData(packedInput.vmesh, input, V, posInput, surfaceData, builtinData, l, d);\n\n\n\n              #ifdef _DEPTHOFFSET_ON\n                  outputDepth = posInput.deviceDepth;\n              #endif\n\n              #ifdef WRITE_NORMAL_BUFFER\n                  EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), posInput.positionSS, outNormalBuffer);\n                  #ifdef WRITE_MSAA_DEPTH\n                  // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n                  depthColor = packedInput.vmesh.pos.z;\n                  #endif\n              #elif defined(WRITE_MSAA_DEPTH) // When we are MSAA depth only without normal buffer\n                  // Due to the binding order of these two render targets, we need to have them both declared\n                  outNormalBuffer = float4(0.0, 0.0, 0.0, 1.0);\n                  // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n                  depthColor = packedInput.vmesh.pos.z;\n              #elif defined(SCENESELECTIONPASS)\n                  // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly\n                  outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);\n              #endif\n              }\n\n\n\n\n            ENDHLSL\n        }\n        \n      Pass\n        {\n            // based on HDLitPass.template\n            Name \"META\"\n            Tags { \"LightMode\" = \"META\" }\n        \n            //-------------------------------------------------------------------------------------\n            // Render Modes (Blend, Cull, ZTest, Stencil, etc)\n            //-------------------------------------------------------------------------------------\n            \n            Cull Off\n        \n            \n        \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 ps4 xboxone vulkan metal switch\n            //#pragma enable_d3d11_debug_symbols\n        \n            #pragma multi_compile_instancing\n\n            #pragma multi_compile_local _ _ALPHATEST_ON\n\n\n            #pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n            #pragma shader_feature_local _DOUBLESIDED_ON\n            #pragma shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n        \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            // #define _ENABLE_FOG_ON_TRANSPARENT 1\n            #define _AMBIENT_OCCLUSION 1\n            #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n        \n               #pragma shader_feature_local _ _MASKMAP\n   #pragma shader_feature_local _ _DETAIL\n   #pragma shader_feature_local _ _EMISSION\n\n   #define _HDRP 1\n\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n\n            #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #define REQUIRE_DEPTH_TEXTURE\n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler_##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler_##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler_##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler_##samp, coord)\n\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      half3 UnpackNormal(half4 packednormal)\n      {\n         half3 normal;\n         normal.xy = packednormal.wy * 2 - 1;\n         normal.z = sqrt(1 - normal.x*normal.x - normal.y * normal.y);\n         return normal;\n      }\n\n      half3 UnpackScaleNormal(half4 packednormal, half bumpScale)\n      {\n\t     #if defined(UNITY_NO_DXT5nm)\n\t        return packednormal.xyz * 2 - 1;\n\t     #else\n\t\t     half3 normal;\n\t\t     normal.xy = (packednormal.wy * 2 - 1);\n\t        #if (SHADER_TARGET >= 30)\n\t\t        normal.xy *= bumpScale;\n\t\t     #endif\n\t\t     normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n\t        return normal;\n\t     #endif\n      }\t\n\n\n// HDRP Adapter stuff\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n            #define OUTPUT_SPLIT_LIGHTING\n            #endif\n        \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n        \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n        \n            // define FragInputs structure\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n        \n\n    // We need isFontFace when using double sided\n        #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)\n            #define VARYINGS_NEED_CULLFACE\n        #endif\n        \n\n        \n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n        #ifdef DEBUG_DISPLAY\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n        #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n        \n        #if (SHADERPASS == SHADERPASS_FORWARD)\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n        \n            #define HAS_LIGHTLOOP\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n        #else\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n        #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n        \n            // Used by SceneSelectionPass\n            int _ObjectId;\n            int _PassValue;\n        \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCCOORD3;\n               float4 texcoord1 : TEXCCOORD4;\n               float4 texcoord2 : TEXCCOORD5;\n               // float4 texcoord3 : TEXCCOORD6;\n               // float4 screenPos : TEXCOORD7;\n               // float4 color : COLOR;\n\n               // float4 extraData0 : TEXCOORD8;\n               // float4 extraData1 : TEXCOORD9;\n               // float4 extraData2 : TEXCOORD10;\n               // float4 extraData3 : TEXCOORD11;\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n            };\n\n\n  \n            \n            \n            // data describing the user output of a pixel\n            struct LightingInputs\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half Alpha;\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half Anisotropy;\n               half iridescenceMask;\n               half iridescenceThickness;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n\n               float3x3 TBNMatrix;\n            };\n\n            struct VertexData\n            {\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n            \n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n\n               \n               // float4 extraData0 : TEXCOORD4;\n               // float4 extraData1 : TEXCOORD5;\n               // float4 extraData2 : TEXCOORD6;\n               // float4 extraData3 : TEXCOORD7;\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraData\n            {\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), p); };\n               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), p); };\n               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }\n               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n\n               float _StencilRef;\n               float _StencilWriteMask;\n               float _StencilRefDepth;\n               float _StencilWriteMaskDepth;\n               float _StencilRefMV;\n               float _StencilWriteMaskMV;\n               float _StencilRefDistortionVec;\n               float _StencilWriteMaskDistortionVec;\n               float _StencilWriteMaskGBuffer;\n               float _StencilRefGBuffer;\n               float _ZTestGBuffer;\n               float _RequireSplitLighting;\n               float _ReceivesSSR;\n               float _ZWrite;\n               float _CullMode;\n               float _TransparentSortPriority;\n               float _CullModeForward;\n               float _TransparentCullMode;\n               float _ZTestDepthEqualForOpaque;\n               float _ZTestTransparent;\n               float _TransparentBackfaceEnable;\n               float _AlphaCutoffEnable;\n               float _UseShadowThreshold;\n               float _DoubleSidedEnable;\n               float _DoubleSidedNormalMode;\n               float4 _DoubleSidedConstants;\n\n               \thalf4 _Tint;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half _EmissionStrength;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n\n\n            CBUFFER_END\n\n            \n   half3 BlendDetailNormal(half3 n1, half3 n2)\n   {\n      return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n   }\n\n   // We share samplers with the albedo - which free's up more for stacking.\n\n   UNITY_DECLARE_TEX2D(_AlbedoMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_NormalMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_MaskMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_EmissionMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_DetailMap);\n\n\n\tvoid SurfaceFunction(inout LightingInputs o, ShaderData d)\n\t{\n      float2 uv = d.texcoord0.xy * _AlbedoMap_ST.xy + _AlbedoMap_ST.zw;\n\n      half4 c = UNITY_SAMPLE_TEX2D(_AlbedoMap, uv);\n      o.Albedo = c.rgb * _Tint.rgb;\n\t\to.Normal = UnpackScaleNormal(UNITY_SAMPLE_TEX2D_SAMPLER(_NormalMap, _AlbedoMap, uv), _NormalStrength);\n\n      half detailMask = 1;\n      #if _MASKMAP\n          // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = UNITY_SAMPLE_TEX2D_SAMPLER(_MaskMap, _AlbedoMap, uv);\n         o.Metallic = mask.r;\n         o.Occlusion = mask.g;\n         o.Smoothness = mask.a;\n         detailMask = mask.b;\n      #endif // separate maps\n\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap, _AlbedoMap, uv).rgb * _EmissionStrength;\n      #endif\n\n      #if defined(_DETAIL)\n         float2 detailUV = uv * _DetailMap_ST.xy + _DetailMap_ST.zw;\n         half4 detailSample = UNITY_SAMPLE_TEX2D_SAMPLER(_DetailMap, _AlbedoMap, detailUV);\n         o.Normal = BlendDetailNormal(o.Normal, UnpackScaleNormal(detailSample, _DetailNormalStrength * detailMask));\n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * detailSample.z, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n\n\t\to.Alpha = c.a;\n\t}\n\n\n\n        \n            void ChainSurfaceFunction(inout LightingInputs l, ShaderData d)\n            {\n                   SurfaceFunction(l, d);\n                 // SurfaceFunction_Ext1(l, d);\n                 // SurfaceFunction_Ext2(l, d);\n                 // SurfaceFunction_Ext3(l, d);\n                 // SurfaceFunction_Ext4(l, d);\n                 // SurfaceFunction_Ext5(l, d);\n                 // SurfaceFunction_Ext6(l, d);\n                 // SurfaceFunction_Ext7(l, d);\n                 // SurfaceFunction_Ext8(l, d);\n                 // SurfaceFunction_Ext9(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraData d = (ExtraData)0;\n                 //  ModifyVertex(v, d);\n                 // ModifyVertex_Ext1(v, d);\n                 // ModifyVertex_Ext2(v, d);\n                 // ModifyVertex_Ext3(v, d);\n                 // ModifyVertex_Ext4(v, d);\n                 // ModifyVertex_Ext5(v, d);\n                 // ModifyVertex_Ext6(v, d);\n                 // ModifyVertex_Ext7(v, d);\n                 // ModifyVertex_Ext8(v, d);\n                 // ModifyVertex_Ext9(v, d);\n                 // v2p.extraData0 = d.extraData0;\n                 // v2p.extraData1 = d.extraData1;\n                 // v2p.extraData2 = d.extraData2;\n                 // v2p.extraData3 = d.extraData3;\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraData d = (ExtraData)0;\n               //  ModifyTessellatedVertex(v, d);\n               // ModifyTessellatedVertex_Ext1(v, d);\n               // ModifyTessellatedVertex_Ext2(v, d);\n               // ModifyTessellatedVertex_Ext3(v, d);\n               // ModifyTessellatedVertex_Ext4(v, d);\n               // ModifyTessellatedVertex_Ext5(v, d);\n               // ModifyTessellatedVertex_Ext6(v, d);\n               // ModifyTessellatedVertex_Ext7(v, d);\n               // ModifyTessellatedVertex_Ext8(v, d);\n               // ModifyTessellatedVertex_Ext9(v, d);\n               // v2p.extraData0 = d.extraData0;\n               // v2p.extraData1 = d.extraData1;\n               // v2p.extraData2 = d.extraData2;\n               // v2p.extraData3 = d.extraData3;\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i)\n         {\n            ShaderData d = (ShaderData)0;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = i.worldNormal;\n            d.worldSpaceTangent = i.worldTangent.xyz;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n            // d.texcoord3 = i.texcoord3;\n            // d.vertexColor = i.color;\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            // d.localSpacePosition = mul(GetWorldToObjectMatrix(), i.worldPos);\n            // d.localSpaceNormal = mul(GetWorldToObjectMatrix(), i.worldNormal);\n            // d.localSpaceTangent = mul(GetWorldToObjectMatrix(), i.worldTangent.xyz);\n\n            // d.screenPos = i.screenPos;\n            // d.screenUV = i.screenPos.xy / i.screenPos.w;\n\n            // d.extraData0 = i.extraData0;\n            // d.extraData1 = i.extraData1;\n            // d.extraData2 = i.extraData2;\n            // d.extraData3 = i.extraData3;\n\n            return d;\n         }\n         \n\n            \n\nstruct VaryingsToPS\n{\n   VertexToPixel vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      VaryingsPassToPS vpass;\n   #endif\n};\n\nstruct PackedVaryingsToPS\n{\n   #ifdef VARYINGS_NEED_PASS\n      PackedVaryingsPassToPS vpass;\n   #endif\n   VertexToPixel vmesh;\n\n   UNITY_VERTEX_OUTPUT_STEREO\n};\n\nPackedVaryingsToPS PackVaryingsToPS(VaryingsToPS input)\n{\n   PackedVaryingsToPS output = (PackedVaryingsToPS)0;\n   output.vmesh = input.vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      output.vpass = PackVaryingsPassToPS(input.vpass);\n   #endif\n\n   UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n   return output;\n}\n\n\n\n\nVertexToPixel VertMesh(VertexData input)\n{\n    VertexToPixel output = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(input);\n    UNITY_TRANSFER_INSTANCE_ID(input, output);\n\n    \n    ChainModifyVertex(input, output);\n\n\n    // This return the camera relative position (if enable)\n    float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n    float3 normalWS = TransformObjectToWorldNormal(input.normal);\n    float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n    output.worldPos = positionRWS;\n    output.pos = TransformWorldToHClip(positionRWS);\n    output.worldNormal = normalWS;\n    output.worldTangent = tangentWS;\n\n\n    output.texcoord0 = input.texcoord0;\n    output.texcoord1 = input.texcoord1;\n    output.texcoord2 = input.texcoord2;\n    // output.texcoord3 = input.texcoord3;\n    // output.color = input.color;\n\n    return output;\n}\n\n\n#if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\nvoid MeshDecalsPositionZBias(inout VaryingsToPS input)\n{\n#if defined(UNITY_REVERSED_Z)\n    input.vmesh.pos.z -= _DecalMeshDepthBias;\n#else\n    input.vmesh.pos.z += _DecalMeshDepthBias;\n#endif\n}\n#endif\n\n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n// This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\nfloat unity_OneOverOutputBoost;\nfloat unity_MaxOutputValue;\n\nCBUFFER_START(UnityMetaPass)\n// x = use uv1 as raster position\n// y = use uv2 as raster position\nbool4 unity_MetaVertexControl;\n\n// x = return albedo\n// y = return normal\nbool4 unity_MetaFragmentControl;\nCBUFFER_END\n\nPackedVaryingsToPS Vert(VertexData inputMesh)\n{\n    VaryingsToPS output = (VaryingsToPS)0;\n    output.vmesh = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(inputMesh);\n    UNITY_TRANSFER_INSTANCE_ID(inputMesh, output.vmesh);\n\n    // Output UV coordinate in vertex shader\n    float2 uv = float2(0.0, 0.0);\n\n    if (unity_MetaVertexControl.x)\n    {\n        uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n    }\n    else if (unity_MetaVertexControl.y)\n    {\n        uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n    }\n\n    // OpenGL right now needs to actually use the incoming vertex position\n    // so we create a fake dependency on it here that haven't any impact.\n    output.vmesh.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n#ifdef VARYINGS_NEED_POSITION_WS\n    output.vmesh.worldPos = TransformObjectToWorld(inputMesh.vertex);\n#endif\n\n#ifdef VARYINGS_NEED_TANGENT_TO_WORLD\n    // Normal is required for triplanar mapping\n    output.vmesh.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n    // Not required but assign to silent compiler warning\n    output.vmesh.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n#endif\n\n    output.vmesh.texcoord0 = inputMesh.texcoord0;\n    output.vmesh.texcoord1 = inputMesh.texcoord1;\n    output.vmesh.texcoord2 = inputMesh.texcoord2;\n    // output.vmesh.texCoord3 = inputMesh.texcoord3;\n    // output.vmesh.color = inputMesh.color;\n\n    return PackVaryingsToPS(output);\n}\n#else\n\nPackedVaryingsToPS Vert(VertexData inputMesh)\n{\n    VaryingsToPS varyingsType;\n    varyingsType.vmesh = VertMesh(inputMesh);\n    #if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\n       MeshDecalsPositionZBias(varyingsType);\n    #endif\n    return PackVaryingsToPS(varyingsType);\n}\n\n#endif\n\n\n\n            \n\n            \n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n            \n                    output.positionRWS = input.worldPos;\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n                    //output.color = input.color;\n                    //#if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                    //output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                    //#elif SHADER_STAGE_FRAGMENT\n                    // output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                    //#endif // SHADER_STAGE_FRAGMENT\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout LightingInputs surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n        \n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n        \n           #ifdef _HAS_REFRACTION\n                   if (_EnableSSRefraction)\n                   {\n                       // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                       // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                       // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n        \n                       surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                       surfaceDescription.Alpha = 1.0;\n                   }\n                   else\n                   {\n                       surfaceData.ior = 1.0;\n                       surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                       surfaceData.atDistance = 1.0;\n                       surfaceData.transmittanceMask = 0.0;\n                       surfaceDescription.Alpha = 1.0;\n                   }\n           #else\n                   surfaceData.ior = 1.0;\n                   surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                   surfaceData.atDistance = 1.0;\n                   surfaceData.transmittanceMask = 0.0;\n           #endif\n                \n                   // These static material feature allow compile time optimization\n                   surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n           #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n           #endif\n           #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n           #endif\n           #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n           #endif\n                   // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n        \n           #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n           #endif\n           #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n           #endif\n        \n           #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                   // Require to have setup baseColor\n                   // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                   surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n           #endif\n        \n           #ifdef _DOUBLESIDED_ON\n               float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n           #else\n               float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n           #endif\n        \n                   // tangent-space normal\n                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                   normalTS = surfaceDescription.Normal;\n        \n                   // compute world space normal\n                   GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n        \n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                   // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent, fragInputs.tangentToWorld);\n        \n           #if HAVE_DECALS\n                   if (_EnableDecals)\n                   {\n                       #if VERSION_GREATER_EQUAL(10,2)\n                          DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput,  surfaceData.geomNormalWS, surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData,  surfaceData.geomNormalWS, surfaceData);\n                       #else\n                          DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                       #endif\n                   }\n           #endif\n        \n                   bentNormalWS = surfaceData.normalWS;\n                   // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n        \n                   surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n        \n        \n                   // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                   // If user provide bent normal then we process a better term\n           #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                   // Just use the value passed through via the slot (not active otherwise)\n           #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                   // If we have bent normal and ambient occlusion, process a specular occlusion\n                   surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n           #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                   surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n           #endif\n        \n           #ifdef _ENABLE_GEOMETRIC_SPECULAR_AA\n                   surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n           #endif\n        \n           #ifdef DEBUG_DISPLAY\n                   if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                   {\n                       // TODO: need to update mip info\n                       surfaceData.metallic = 0;\n                   }\n        \n                   // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                   // as it can modify attribute use for static lighting\n                   ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n           #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout LightingInputs l, inout ShaderData d)\n               {\n                 #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                     uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to _ScreenSize values\n                     LODDitheringTransition(fadeMaskSeed, unity_LODFade.x);\n                 #endif\n        \n                 #ifdef _DOUBLESIDED_ON\n                     float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                 #else\n                     float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                 #endif\n        \n                 ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n\n                 d = CreateShaderData(m2ps);\n\n                 l = (LightingInputs)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n\n                 ChainSurfaceFunction(l, d);\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n        \n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 builtinData.emissiveColor = l.Emission;\n        \n        \n                 #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     //builtinData.distortion = surfaceDescription.Distortion;\n                     //builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                     builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                 #else\n                     builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                 #endif\n        \n                   PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n               }\n\n\n            float4 Frag(PackedVaryingsToPS packedInput) : SV_Target\n            {\n                FragInputs input = BuildFragInputs(packedInput.vmesh);\n\n                // input.positionSS is SV_Position\n                PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n            #ifdef VARYINGS_NEED_POSITION_WS\n                float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n            #else\n                // Unused\n                float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0\n            #endif\n\n                SurfaceData surfaceData;\n                BuiltinData builtinData;\n                LightingInputs l;\n                ShaderData d;\n                GetSurfaceAndBuiltinData(packedInput.vmesh, input, V, posInput, surfaceData, builtinData, l, d);\n\n                // no debug apply during light transport pass\n\n                BSDFData bsdfData = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);\n                LightTransportData lightTransportData = GetLightTransportData(surfaceData, builtinData, bsdfData);\n\n                // This shader is call two times. Once for getting emissiveColor, the other time to get diffuseColor\n                // We use unity_MetaFragmentControl to make the distinction.\n                float4 res = float4(0.0, 0.0, 0.0, 1.0);\n\n                if (unity_MetaFragmentControl.x)\n                {\n                    // Apply diffuseColor Boost from LightmapSettings.\n                    // put abs here to silent a warning, no cost, no impact as color is assume to be positive.\n                    res.rgb = clamp(pow(abs(lightTransportData.diffuseColor), saturate(unity_OneOverOutputBoost)), 0, unity_MaxOutputValue);\n                }\n\n                if (unity_MetaFragmentControl.y)\n                {\n                    // emissive use HDR format\n                    res.rgb = lightTransportData.emissiveColor;\n                }\n\n                return res;\n            }\n\n\n\n            ENDHLSL\n        }\n        \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"SceneSelectionPass\"\n            Tags { \"LightMode\" = \"SceneSelectionPass\" }\n        \n            ColorMask 0\n\n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 ps4 xboxone vulkan metal switch\n            //#pragma enable_d3d11_debug_symbols\n        \n            #pragma multi_compile_instancing\n            #pragma instancing_options assumeuniformscaling nomatrices nolightprobe nolightmap renderinglayer\n        \n            #pragma multi_compile_local _ _ALPHATEST_ON\n\n\n            //#pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _DOUBLESIDED_ON\n            //#pragma shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n        \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            // #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n        \n               #pragma shader_feature_local _ _MASKMAP\n   #pragma shader_feature_local _ _DETAIL\n   #pragma shader_feature_local _ _EMISSION\n\n   #define _HDRP 1\n\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n            #define SHADERPASS SHADERPASS_DEPTH_ONLY\n            #define SCENESELECTIONPASS\n            #pragma editor_sync_compilation\n            #define RAYTRACING_SHADER_GRAPH_HIGH\n\n        \n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler_##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler_##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler_##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler_##samp, coord)\n\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      half3 UnpackNormal(half4 packednormal)\n      {\n         half3 normal;\n         normal.xy = packednormal.wy * 2 - 1;\n         normal.z = sqrt(1 - normal.x*normal.x - normal.y * normal.y);\n         return normal;\n      }\n\n      half3 UnpackScaleNormal(half4 packednormal, half bumpScale)\n      {\n\t     #if defined(UNITY_NO_DXT5nm)\n\t        return packednormal.xyz * 2 - 1;\n\t     #else\n\t\t     half3 normal;\n\t\t     normal.xy = (packednormal.wy * 2 - 1);\n\t        #if (SHADER_TARGET >= 30)\n\t\t        normal.xy *= bumpScale;\n\t\t     #endif\n\t\t     normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n\t        return normal;\n\t     #endif\n      }\t\n\n\n// HDRP Adapter stuff\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n            #define OUTPUT_SPLIT_LIGHTING\n            #endif\n        \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n        \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n        \n            // define FragInputs structure\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n        \n\n    // We need isFontFace when using double sided\n        #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)\n            #define VARYINGS_NEED_CULLFACE\n        #endif\n        \n\n        \n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n        #ifdef DEBUG_DISPLAY\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n        #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n        \n        #if (SHADERPASS == SHADERPASS_FORWARD)\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n        \n            #define HAS_LIGHTLOOP\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n        #else\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n        #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n        \n            // Used by SceneSelectionPass\n            int _ObjectId;\n            int _PassValue;\n        \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCCOORD3;\n               float4 texcoord1 : TEXCCOORD4;\n               float4 texcoord2 : TEXCCOORD5;\n               // float4 texcoord3 : TEXCCOORD6;\n               // float4 screenPos : TEXCOORD7;\n               // float4 color : COLOR;\n\n               // float4 extraData0 : TEXCOORD8;\n               // float4 extraData1 : TEXCOORD9;\n               // float4 extraData2 : TEXCOORD10;\n               // float4 extraData3 : TEXCOORD11;\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n            };\n      \n  \n            \n            \n            // data describing the user output of a pixel\n            struct LightingInputs\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half Alpha;\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half Anisotropy;\n               half iridescenceMask;\n               half iridescenceThickness;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n\n               float3x3 TBNMatrix;\n            };\n\n            struct VertexData\n            {\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n            \n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n\n               \n               // float4 extraData0 : TEXCOORD4;\n               // float4 extraData1 : TEXCOORD5;\n               // float4 extraData2 : TEXCOORD6;\n               // float4 extraData3 : TEXCOORD7;\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraData\n            {\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), p); };\n               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), p); };\n               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }\n               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n\n               float _StencilRef;\n               float _StencilWriteMask;\n               float _StencilRefDepth;\n               float _StencilWriteMaskDepth;\n               float _StencilRefMV;\n               float _StencilWriteMaskMV;\n               float _StencilRefDistortionVec;\n               float _StencilWriteMaskDistortionVec;\n               float _StencilWriteMaskGBuffer;\n               float _StencilRefGBuffer;\n               float _ZTestGBuffer;\n               float _RequireSplitLighting;\n               float _ReceivesSSR;\n               float _ZWrite;\n               float _CullMode;\n               float _TransparentSortPriority;\n               float _CullModeForward;\n               float _TransparentCullMode;\n               float _ZTestDepthEqualForOpaque;\n               float _ZTestTransparent;\n               float _TransparentBackfaceEnable;\n               float _AlphaCutoffEnable;\n               float _UseShadowThreshold;\n               float _DoubleSidedEnable;\n               float _DoubleSidedNormalMode;\n               float4 _DoubleSidedConstants;\n\n               \thalf4 _Tint;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half _EmissionStrength;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n\n\n            CBUFFER_END\n\n            \n   half3 BlendDetailNormal(half3 n1, half3 n2)\n   {\n      return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n   }\n\n   // We share samplers with the albedo - which free's up more for stacking.\n\n   UNITY_DECLARE_TEX2D(_AlbedoMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_NormalMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_MaskMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_EmissionMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_DetailMap);\n\n\n\tvoid SurfaceFunction(inout LightingInputs o, ShaderData d)\n\t{\n      float2 uv = d.texcoord0.xy * _AlbedoMap_ST.xy + _AlbedoMap_ST.zw;\n\n      half4 c = UNITY_SAMPLE_TEX2D(_AlbedoMap, uv);\n      o.Albedo = c.rgb * _Tint.rgb;\n\t\to.Normal = UnpackScaleNormal(UNITY_SAMPLE_TEX2D_SAMPLER(_NormalMap, _AlbedoMap, uv), _NormalStrength);\n\n      half detailMask = 1;\n      #if _MASKMAP\n          // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = UNITY_SAMPLE_TEX2D_SAMPLER(_MaskMap, _AlbedoMap, uv);\n         o.Metallic = mask.r;\n         o.Occlusion = mask.g;\n         o.Smoothness = mask.a;\n         detailMask = mask.b;\n      #endif // separate maps\n\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap, _AlbedoMap, uv).rgb * _EmissionStrength;\n      #endif\n\n      #if defined(_DETAIL)\n         float2 detailUV = uv * _DetailMap_ST.xy + _DetailMap_ST.zw;\n         half4 detailSample = UNITY_SAMPLE_TEX2D_SAMPLER(_DetailMap, _AlbedoMap, detailUV);\n         o.Normal = BlendDetailNormal(o.Normal, UnpackScaleNormal(detailSample, _DetailNormalStrength * detailMask));\n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * detailSample.z, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n\n\t\to.Alpha = c.a;\n\t}\n\n\n\n        \n            void ChainSurfaceFunction(inout LightingInputs l, ShaderData d)\n            {\n                   SurfaceFunction(l, d);\n                 // SurfaceFunction_Ext1(l, d);\n                 // SurfaceFunction_Ext2(l, d);\n                 // SurfaceFunction_Ext3(l, d);\n                 // SurfaceFunction_Ext4(l, d);\n                 // SurfaceFunction_Ext5(l, d);\n                 // SurfaceFunction_Ext6(l, d);\n                 // SurfaceFunction_Ext7(l, d);\n                 // SurfaceFunction_Ext8(l, d);\n                 // SurfaceFunction_Ext9(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraData d = (ExtraData)0;\n                 //  ModifyVertex(v, d);\n                 // ModifyVertex_Ext1(v, d);\n                 // ModifyVertex_Ext2(v, d);\n                 // ModifyVertex_Ext3(v, d);\n                 // ModifyVertex_Ext4(v, d);\n                 // ModifyVertex_Ext5(v, d);\n                 // ModifyVertex_Ext6(v, d);\n                 // ModifyVertex_Ext7(v, d);\n                 // ModifyVertex_Ext8(v, d);\n                 // ModifyVertex_Ext9(v, d);\n                 // v2p.extraData0 = d.extraData0;\n                 // v2p.extraData1 = d.extraData1;\n                 // v2p.extraData2 = d.extraData2;\n                 // v2p.extraData3 = d.extraData3;\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraData d = (ExtraData)0;\n               //  ModifyTessellatedVertex(v, d);\n               // ModifyTessellatedVertex_Ext1(v, d);\n               // ModifyTessellatedVertex_Ext2(v, d);\n               // ModifyTessellatedVertex_Ext3(v, d);\n               // ModifyTessellatedVertex_Ext4(v, d);\n               // ModifyTessellatedVertex_Ext5(v, d);\n               // ModifyTessellatedVertex_Ext6(v, d);\n               // ModifyTessellatedVertex_Ext7(v, d);\n               // ModifyTessellatedVertex_Ext8(v, d);\n               // ModifyTessellatedVertex_Ext9(v, d);\n               // v2p.extraData0 = d.extraData0;\n               // v2p.extraData1 = d.extraData1;\n               // v2p.extraData2 = d.extraData2;\n               // v2p.extraData3 = d.extraData3;\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i)\n         {\n            ShaderData d = (ShaderData)0;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = i.worldNormal;\n            d.worldSpaceTangent = i.worldTangent.xyz;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n            // d.texcoord3 = i.texcoord3;\n            // d.vertexColor = i.color;\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            // d.localSpacePosition = mul(GetWorldToObjectMatrix(), i.worldPos);\n            // d.localSpaceNormal = mul(GetWorldToObjectMatrix(), i.worldNormal);\n            // d.localSpaceTangent = mul(GetWorldToObjectMatrix(), i.worldTangent.xyz);\n\n            // d.screenPos = i.screenPos;\n            // d.screenUV = i.screenPos.xy / i.screenPos.w;\n\n            // d.extraData0 = i.extraData0;\n            // d.extraData1 = i.extraData1;\n            // d.extraData2 = i.extraData2;\n            // d.extraData3 = i.extraData3;\n\n            return d;\n         }\n         \n\n            \n\nstruct VaryingsToPS\n{\n   VertexToPixel vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      VaryingsPassToPS vpass;\n   #endif\n};\n\nstruct PackedVaryingsToPS\n{\n   #ifdef VARYINGS_NEED_PASS\n      PackedVaryingsPassToPS vpass;\n   #endif\n   VertexToPixel vmesh;\n\n   UNITY_VERTEX_OUTPUT_STEREO\n};\n\nPackedVaryingsToPS PackVaryingsToPS(VaryingsToPS input)\n{\n   PackedVaryingsToPS output = (PackedVaryingsToPS)0;\n   output.vmesh = input.vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      output.vpass = PackVaryingsPassToPS(input.vpass);\n   #endif\n\n   UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n   return output;\n}\n\n\n\n\nVertexToPixel VertMesh(VertexData input)\n{\n    VertexToPixel output = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(input);\n    UNITY_TRANSFER_INSTANCE_ID(input, output);\n\n    \n    ChainModifyVertex(input, output);\n\n\n    // This return the camera relative position (if enable)\n    float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n    float3 normalWS = TransformObjectToWorldNormal(input.normal);\n    float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n    output.worldPos = positionRWS;\n    output.pos = TransformWorldToHClip(positionRWS);\n    output.worldNormal = normalWS;\n    output.worldTangent = tangentWS;\n\n\n    output.texcoord0 = input.texcoord0;\n    output.texcoord1 = input.texcoord1;\n    output.texcoord2 = input.texcoord2;\n    // output.texcoord3 = input.texcoord3;\n    // output.color = input.color;\n\n    return output;\n}\n\n\n#if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\nvoid MeshDecalsPositionZBias(inout VaryingsToPS input)\n{\n#if defined(UNITY_REVERSED_Z)\n    input.vmesh.pos.z -= _DecalMeshDepthBias;\n#else\n    input.vmesh.pos.z += _DecalMeshDepthBias;\n#endif\n}\n#endif\n\n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n// This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\nfloat unity_OneOverOutputBoost;\nfloat unity_MaxOutputValue;\n\nCBUFFER_START(UnityMetaPass)\n// x = use uv1 as raster position\n// y = use uv2 as raster position\nbool4 unity_MetaVertexControl;\n\n// x = return albedo\n// y = return normal\nbool4 unity_MetaFragmentControl;\nCBUFFER_END\n\nPackedVaryingsToPS Vert(VertexData inputMesh)\n{\n    VaryingsToPS output = (VaryingsToPS)0;\n    output.vmesh = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(inputMesh);\n    UNITY_TRANSFER_INSTANCE_ID(inputMesh, output.vmesh);\n\n    // Output UV coordinate in vertex shader\n    float2 uv = float2(0.0, 0.0);\n\n    if (unity_MetaVertexControl.x)\n    {\n        uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n    }\n    else if (unity_MetaVertexControl.y)\n    {\n        uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n    }\n\n    // OpenGL right now needs to actually use the incoming vertex position\n    // so we create a fake dependency on it here that haven't any impact.\n    output.vmesh.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n#ifdef VARYINGS_NEED_POSITION_WS\n    output.vmesh.worldPos = TransformObjectToWorld(inputMesh.vertex);\n#endif\n\n#ifdef VARYINGS_NEED_TANGENT_TO_WORLD\n    // Normal is required for triplanar mapping\n    output.vmesh.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n    // Not required but assign to silent compiler warning\n    output.vmesh.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n#endif\n\n    output.vmesh.texcoord0 = inputMesh.texcoord0;\n    output.vmesh.texcoord1 = inputMesh.texcoord1;\n    output.vmesh.texcoord2 = inputMesh.texcoord2;\n    // output.vmesh.texCoord3 = inputMesh.texcoord3;\n    // output.vmesh.color = inputMesh.color;\n\n    return PackVaryingsToPS(output);\n}\n#else\n\nPackedVaryingsToPS Vert(VertexData inputMesh)\n{\n    VaryingsToPS varyingsType;\n    varyingsType.vmesh = VertMesh(inputMesh);\n    #if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\n       MeshDecalsPositionZBias(varyingsType);\n    #endif\n    return PackVaryingsToPS(varyingsType);\n}\n\n#endif\n\n\n\n            \n\n            \n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n            \n                    output.positionRWS = input.worldPos;\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n                    //output.color = input.color;\n                    //#if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                    //output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                    //#elif SHADER_STAGE_FRAGMENT\n                    // output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                    //#endif // SHADER_STAGE_FRAGMENT\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout LightingInputs surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n        \n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n        \n           #ifdef _HAS_REFRACTION\n                   if (_EnableSSRefraction)\n                   {\n                       // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                       // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                       // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n        \n                       surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                       surfaceDescription.Alpha = 1.0;\n                   }\n                   else\n                   {\n                       surfaceData.ior = 1.0;\n                       surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                       surfaceData.atDistance = 1.0;\n                       surfaceData.transmittanceMask = 0.0;\n                       surfaceDescription.Alpha = 1.0;\n                   }\n           #else\n                   surfaceData.ior = 1.0;\n                   surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                   surfaceData.atDistance = 1.0;\n                   surfaceData.transmittanceMask = 0.0;\n           #endif\n                \n                   // These static material feature allow compile time optimization\n                   surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n           #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n           #endif\n           #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n           #endif\n           #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n           #endif\n                   // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n        \n           #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n           #endif\n           #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n           #endif\n        \n           #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                   // Require to have setup baseColor\n                   // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                   surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n           #endif\n        \n           #ifdef _DOUBLESIDED_ON\n               float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n           #else\n               float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n           #endif\n        \n                   // tangent-space normal\n                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                   normalTS = surfaceDescription.Normal;\n        \n                   // compute world space normal\n                   GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n        \n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                   // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent, fragInputs.tangentToWorld);\n        \n           #if HAVE_DECALS\n                   if (_EnableDecals)\n                   {\n                       #if VERSION_GREATER_EQUAL(10,2)\n                          DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput,  surfaceData.geomNormalWS, surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData,  surfaceData.geomNormalWS, surfaceData);\n                       #else\n                          DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                       #endif\n                   }\n           #endif\n        \n                   bentNormalWS = surfaceData.normalWS;\n                   // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n        \n                   surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n        \n        \n                   // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                   // If user provide bent normal then we process a better term\n           #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                   // Just use the value passed through via the slot (not active otherwise)\n           #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                   // If we have bent normal and ambient occlusion, process a specular occlusion\n                   surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n           #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                   surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n           #endif\n        \n           #ifdef _ENABLE_GEOMETRIC_SPECULAR_AA\n                   surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n           #endif\n        \n           #ifdef DEBUG_DISPLAY\n                   if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                   {\n                       // TODO: need to update mip info\n                       surfaceData.metallic = 0;\n                   }\n        \n                   // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                   // as it can modify attribute use for static lighting\n                   ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n           #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout LightingInputs l, inout ShaderData d)\n               {\n                 #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                     uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to _ScreenSize values\n                     LODDitheringTransition(fadeMaskSeed, unity_LODFade.x);\n                 #endif\n        \n                 #ifdef _DOUBLESIDED_ON\n                     float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                 #else\n                     float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                 #endif\n        \n                 ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n\n                 d = CreateShaderData(m2ps);\n\n                 l = (LightingInputs)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n\n                 ChainSurfaceFunction(l, d);\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n        \n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 builtinData.emissiveColor = l.Emission;\n        \n        \n                 #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     //builtinData.distortion = surfaceDescription.Distortion;\n                     //builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                     builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                 #else\n                     builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                 #endif\n        \n                   PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n               }\n        \n            void Frag(  PackedVaryingsToPS packedInput,\n                        OUTPUT_GBUFFER(outGBuffer)\n                        #ifdef _DEPTHOFFSET_ON\n                        , out float outputDepth : SV_Depth\n                        #endif\n                        )\n            {\n                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(packedInput);\n                  FragInputs input = BuildFragInputs(packedInput.vmesh);\n\n                  // input.positionSS is SV_Position\n                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n                  #ifdef VARYINGS_NEED_POSITION_WS\n                     float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n                  #else\n                     // Unused\n                     float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0\n                  #endif\n\n                  SurfaceData surfaceData;\n                  BuiltinData builtinData;\n                  LightingInputs l;\n                  ShaderData d;\n                  GetSurfaceAndBuiltinData(packedInput.vmesh, input, V, posInput, surfaceData, builtinData, l, d);\n\n\n\n                  ENCODE_INTO_GBUFFER(surfaceData, builtinData, posInput.positionSS, outGBuffer);\n\n                  #ifdef _DEPTHOFFSET_ON\n                        outputDepth = posInput.deviceDepth;\n                  #endif\n            }\n\n            ENDHLSL\n        }\n\n\n        \n      Pass\n        {\n            // based on HDLitPass.template\n            Name \"DepthOnly\"\n            Tags { \"LightMode\" = \"DepthOnly\" }\n        \n            //-------------------------------------------------------------------------------------\n            // Render Modes (Blend, Cull, ZTest, Stencil, etc)\n            //-------------------------------------------------------------------------------------\n            \n            Cull [_CullMode]\n        \n            \n            ZWrite On\n        \n            \n            // Stencil setup\n        Stencil\n        {\n           WriteMask [_StencilWriteMaskDepth]\n           Ref [_StencilRefDepth]\n           Comp Always\n           Pass Replace\n        }\n        \n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 ps4 xboxone vulkan metal switch\n            //#pragma enable_d3d11_debug_symbols\n        \n            #pragma multi_compile_instancing\n        \n        #pragma multi_compile_local _ _ALPHATEST_ON\n        \n            // #pragma multi_compile _ LOD_FADE_CROSSFADE\n        \n            //#pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _DOUBLESIDED_ON\n            //#pragma shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n        \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            // #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            \n               #pragma shader_feature_local _ _MASKMAP\n   #pragma shader_feature_local _ _DETAIL\n   #pragma shader_feature_local _ _EMISSION\n\n   #define _HDRP 1\n\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n            #define SHADERPASS SHADERPASS_DEPTH_ONLY\n            #pragma multi_compile _ WRITE_NORMAL_BUFFER\n            #pragma multi_compile _ WRITE_MSAA_DEPTH\n            #define RAYTRACING_SHADER_GRAPH_HIGH\n                \n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler_##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler_##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler_##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler_##samp, coord)\n\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      half3 UnpackNormal(half4 packednormal)\n      {\n         half3 normal;\n         normal.xy = packednormal.wy * 2 - 1;\n         normal.z = sqrt(1 - normal.x*normal.x - normal.y * normal.y);\n         return normal;\n      }\n\n      half3 UnpackScaleNormal(half4 packednormal, half bumpScale)\n      {\n\t     #if defined(UNITY_NO_DXT5nm)\n\t        return packednormal.xyz * 2 - 1;\n\t     #else\n\t\t     half3 normal;\n\t\t     normal.xy = (packednormal.wy * 2 - 1);\n\t        #if (SHADER_TARGET >= 30)\n\t\t        normal.xy *= bumpScale;\n\t\t     #endif\n\t\t     normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n\t        return normal;\n\t     #endif\n      }\t\n\n\n// HDRP Adapter stuff\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n            #define OUTPUT_SPLIT_LIGHTING\n            #endif\n        \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n        \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n        \n            // define FragInputs structure\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n        \n\n    // We need isFontFace when using double sided\n        #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)\n            #define VARYINGS_NEED_CULLFACE\n        #endif\n        \n\n        \n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n        #ifdef DEBUG_DISPLAY\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n        #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n        \n        #if (SHADERPASS == SHADERPASS_FORWARD)\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n        \n            #define HAS_LIGHTLOOP\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n        #else\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n        #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n        \n            // Used by SceneSelectionPass\n            int _ObjectId;\n            int _PassValue;\n        \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCCOORD3;\n               float4 texcoord1 : TEXCCOORD4;\n               float4 texcoord2 : TEXCCOORD5;\n               // float4 texcoord3 : TEXCCOORD6;\n               // float4 screenPos : TEXCOORD7;\n               // float4 color : COLOR;\n\n               // float4 extraData0 : TEXCOORD8;\n               // float4 extraData1 : TEXCOORD9;\n               // float4 extraData2 : TEXCOORD10;\n               // float4 extraData3 : TEXCOORD11;\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n            };\n\n\n\n            \n            \n            // data describing the user output of a pixel\n            struct LightingInputs\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half Alpha;\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half Anisotropy;\n               half iridescenceMask;\n               half iridescenceThickness;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n\n               float3x3 TBNMatrix;\n            };\n\n            struct VertexData\n            {\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n            \n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n\n               \n               // float4 extraData0 : TEXCOORD4;\n               // float4 extraData1 : TEXCOORD5;\n               // float4 extraData2 : TEXCOORD6;\n               // float4 extraData3 : TEXCOORD7;\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraData\n            {\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), p); };\n               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), p); };\n               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }\n               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n\n               float _StencilRef;\n               float _StencilWriteMask;\n               float _StencilRefDepth;\n               float _StencilWriteMaskDepth;\n               float _StencilRefMV;\n               float _StencilWriteMaskMV;\n               float _StencilRefDistortionVec;\n               float _StencilWriteMaskDistortionVec;\n               float _StencilWriteMaskGBuffer;\n               float _StencilRefGBuffer;\n               float _ZTestGBuffer;\n               float _RequireSplitLighting;\n               float _ReceivesSSR;\n               float _ZWrite;\n               float _CullMode;\n               float _TransparentSortPriority;\n               float _CullModeForward;\n               float _TransparentCullMode;\n               float _ZTestDepthEqualForOpaque;\n               float _ZTestTransparent;\n               float _TransparentBackfaceEnable;\n               float _AlphaCutoffEnable;\n               float _UseShadowThreshold;\n               float _DoubleSidedEnable;\n               float _DoubleSidedNormalMode;\n               float4 _DoubleSidedConstants;\n\n               \thalf4 _Tint;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half _EmissionStrength;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n\n\n            CBUFFER_END\n\n            \n   half3 BlendDetailNormal(half3 n1, half3 n2)\n   {\n      return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n   }\n\n   // We share samplers with the albedo - which free's up more for stacking.\n\n   UNITY_DECLARE_TEX2D(_AlbedoMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_NormalMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_MaskMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_EmissionMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_DetailMap);\n\n\n\tvoid SurfaceFunction(inout LightingInputs o, ShaderData d)\n\t{\n      float2 uv = d.texcoord0.xy * _AlbedoMap_ST.xy + _AlbedoMap_ST.zw;\n\n      half4 c = UNITY_SAMPLE_TEX2D(_AlbedoMap, uv);\n      o.Albedo = c.rgb * _Tint.rgb;\n\t\to.Normal = UnpackScaleNormal(UNITY_SAMPLE_TEX2D_SAMPLER(_NormalMap, _AlbedoMap, uv), _NormalStrength);\n\n      half detailMask = 1;\n      #if _MASKMAP\n          // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = UNITY_SAMPLE_TEX2D_SAMPLER(_MaskMap, _AlbedoMap, uv);\n         o.Metallic = mask.r;\n         o.Occlusion = mask.g;\n         o.Smoothness = mask.a;\n         detailMask = mask.b;\n      #endif // separate maps\n\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap, _AlbedoMap, uv).rgb * _EmissionStrength;\n      #endif\n\n      #if defined(_DETAIL)\n         float2 detailUV = uv * _DetailMap_ST.xy + _DetailMap_ST.zw;\n         half4 detailSample = UNITY_SAMPLE_TEX2D_SAMPLER(_DetailMap, _AlbedoMap, detailUV);\n         o.Normal = BlendDetailNormal(o.Normal, UnpackScaleNormal(detailSample, _DetailNormalStrength * detailMask));\n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * detailSample.z, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n\n\t\to.Alpha = c.a;\n\t}\n\n\n\n        \n            void ChainSurfaceFunction(inout LightingInputs l, ShaderData d)\n            {\n                   SurfaceFunction(l, d);\n                 // SurfaceFunction_Ext1(l, d);\n                 // SurfaceFunction_Ext2(l, d);\n                 // SurfaceFunction_Ext3(l, d);\n                 // SurfaceFunction_Ext4(l, d);\n                 // SurfaceFunction_Ext5(l, d);\n                 // SurfaceFunction_Ext6(l, d);\n                 // SurfaceFunction_Ext7(l, d);\n                 // SurfaceFunction_Ext8(l, d);\n                 // SurfaceFunction_Ext9(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraData d = (ExtraData)0;\n                 //  ModifyVertex(v, d);\n                 // ModifyVertex_Ext1(v, d);\n                 // ModifyVertex_Ext2(v, d);\n                 // ModifyVertex_Ext3(v, d);\n                 // ModifyVertex_Ext4(v, d);\n                 // ModifyVertex_Ext5(v, d);\n                 // ModifyVertex_Ext6(v, d);\n                 // ModifyVertex_Ext7(v, d);\n                 // ModifyVertex_Ext8(v, d);\n                 // ModifyVertex_Ext9(v, d);\n                 // v2p.extraData0 = d.extraData0;\n                 // v2p.extraData1 = d.extraData1;\n                 // v2p.extraData2 = d.extraData2;\n                 // v2p.extraData3 = d.extraData3;\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraData d = (ExtraData)0;\n               //  ModifyTessellatedVertex(v, d);\n               // ModifyTessellatedVertex_Ext1(v, d);\n               // ModifyTessellatedVertex_Ext2(v, d);\n               // ModifyTessellatedVertex_Ext3(v, d);\n               // ModifyTessellatedVertex_Ext4(v, d);\n               // ModifyTessellatedVertex_Ext5(v, d);\n               // ModifyTessellatedVertex_Ext6(v, d);\n               // ModifyTessellatedVertex_Ext7(v, d);\n               // ModifyTessellatedVertex_Ext8(v, d);\n               // ModifyTessellatedVertex_Ext9(v, d);\n               // v2p.extraData0 = d.extraData0;\n               // v2p.extraData1 = d.extraData1;\n               // v2p.extraData2 = d.extraData2;\n               // v2p.extraData3 = d.extraData3;\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i)\n         {\n            ShaderData d = (ShaderData)0;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = i.worldNormal;\n            d.worldSpaceTangent = i.worldTangent.xyz;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n            // d.texcoord3 = i.texcoord3;\n            // d.vertexColor = i.color;\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            // d.localSpacePosition = mul(GetWorldToObjectMatrix(), i.worldPos);\n            // d.localSpaceNormal = mul(GetWorldToObjectMatrix(), i.worldNormal);\n            // d.localSpaceTangent = mul(GetWorldToObjectMatrix(), i.worldTangent.xyz);\n\n            // d.screenPos = i.screenPos;\n            // d.screenUV = i.screenPos.xy / i.screenPos.w;\n\n            // d.extraData0 = i.extraData0;\n            // d.extraData1 = i.extraData1;\n            // d.extraData2 = i.extraData2;\n            // d.extraData3 = i.extraData3;\n\n            return d;\n         }\n         \n\n            \n\nstruct VaryingsToPS\n{\n   VertexToPixel vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      VaryingsPassToPS vpass;\n   #endif\n};\n\nstruct PackedVaryingsToPS\n{\n   #ifdef VARYINGS_NEED_PASS\n      PackedVaryingsPassToPS vpass;\n   #endif\n   VertexToPixel vmesh;\n\n   UNITY_VERTEX_OUTPUT_STEREO\n};\n\nPackedVaryingsToPS PackVaryingsToPS(VaryingsToPS input)\n{\n   PackedVaryingsToPS output = (PackedVaryingsToPS)0;\n   output.vmesh = input.vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      output.vpass = PackVaryingsPassToPS(input.vpass);\n   #endif\n\n   UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n   return output;\n}\n\n\n\n\nVertexToPixel VertMesh(VertexData input)\n{\n    VertexToPixel output = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(input);\n    UNITY_TRANSFER_INSTANCE_ID(input, output);\n\n    \n    ChainModifyVertex(input, output);\n\n\n    // This return the camera relative position (if enable)\n    float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n    float3 normalWS = TransformObjectToWorldNormal(input.normal);\n    float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n    output.worldPos = positionRWS;\n    output.pos = TransformWorldToHClip(positionRWS);\n    output.worldNormal = normalWS;\n    output.worldTangent = tangentWS;\n\n\n    output.texcoord0 = input.texcoord0;\n    output.texcoord1 = input.texcoord1;\n    output.texcoord2 = input.texcoord2;\n    // output.texcoord3 = input.texcoord3;\n    // output.color = input.color;\n\n    return output;\n}\n\n\n#if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\nvoid MeshDecalsPositionZBias(inout VaryingsToPS input)\n{\n#if defined(UNITY_REVERSED_Z)\n    input.vmesh.pos.z -= _DecalMeshDepthBias;\n#else\n    input.vmesh.pos.z += _DecalMeshDepthBias;\n#endif\n}\n#endif\n\n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n// This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\nfloat unity_OneOverOutputBoost;\nfloat unity_MaxOutputValue;\n\nCBUFFER_START(UnityMetaPass)\n// x = use uv1 as raster position\n// y = use uv2 as raster position\nbool4 unity_MetaVertexControl;\n\n// x = return albedo\n// y = return normal\nbool4 unity_MetaFragmentControl;\nCBUFFER_END\n\nPackedVaryingsToPS Vert(VertexData inputMesh)\n{\n    VaryingsToPS output = (VaryingsToPS)0;\n    output.vmesh = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(inputMesh);\n    UNITY_TRANSFER_INSTANCE_ID(inputMesh, output.vmesh);\n\n    // Output UV coordinate in vertex shader\n    float2 uv = float2(0.0, 0.0);\n\n    if (unity_MetaVertexControl.x)\n    {\n        uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n    }\n    else if (unity_MetaVertexControl.y)\n    {\n        uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n    }\n\n    // OpenGL right now needs to actually use the incoming vertex position\n    // so we create a fake dependency on it here that haven't any impact.\n    output.vmesh.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n#ifdef VARYINGS_NEED_POSITION_WS\n    output.vmesh.worldPos = TransformObjectToWorld(inputMesh.vertex);\n#endif\n\n#ifdef VARYINGS_NEED_TANGENT_TO_WORLD\n    // Normal is required for triplanar mapping\n    output.vmesh.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n    // Not required but assign to silent compiler warning\n    output.vmesh.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n#endif\n\n    output.vmesh.texcoord0 = inputMesh.texcoord0;\n    output.vmesh.texcoord1 = inputMesh.texcoord1;\n    output.vmesh.texcoord2 = inputMesh.texcoord2;\n    // output.vmesh.texCoord3 = inputMesh.texcoord3;\n    // output.vmesh.color = inputMesh.color;\n\n    return PackVaryingsToPS(output);\n}\n#else\n\nPackedVaryingsToPS Vert(VertexData inputMesh)\n{\n    VaryingsToPS varyingsType;\n    varyingsType.vmesh = VertMesh(inputMesh);\n    #if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\n       MeshDecalsPositionZBias(varyingsType);\n    #endif\n    return PackVaryingsToPS(varyingsType);\n}\n\n#endif\n\n\n\n            \n\n            \n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n            \n                    output.positionRWS = input.worldPos;\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n                    //output.color = input.color;\n                    //#if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                    //output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                    //#elif SHADER_STAGE_FRAGMENT\n                    // output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                    //#endif // SHADER_STAGE_FRAGMENT\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout LightingInputs surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n        \n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n        \n           #ifdef _HAS_REFRACTION\n                   if (_EnableSSRefraction)\n                   {\n                       // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                       // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                       // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n        \n                       surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                       surfaceDescription.Alpha = 1.0;\n                   }\n                   else\n                   {\n                       surfaceData.ior = 1.0;\n                       surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                       surfaceData.atDistance = 1.0;\n                       surfaceData.transmittanceMask = 0.0;\n                       surfaceDescription.Alpha = 1.0;\n                   }\n           #else\n                   surfaceData.ior = 1.0;\n                   surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                   surfaceData.atDistance = 1.0;\n                   surfaceData.transmittanceMask = 0.0;\n           #endif\n                \n                   // These static material feature allow compile time optimization\n                   surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n           #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n           #endif\n           #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n           #endif\n           #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n           #endif\n                   // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n        \n           #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n           #endif\n           #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n           #endif\n        \n           #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                   // Require to have setup baseColor\n                   // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                   surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n           #endif\n        \n           #ifdef _DOUBLESIDED_ON\n               float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n           #else\n               float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n           #endif\n        \n                   // tangent-space normal\n                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                   normalTS = surfaceDescription.Normal;\n        \n                   // compute world space normal\n                   GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n        \n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                   // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent, fragInputs.tangentToWorld);\n        \n           #if HAVE_DECALS\n                   if (_EnableDecals)\n                   {\n                       #if VERSION_GREATER_EQUAL(10,2)\n                          DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput,  surfaceData.geomNormalWS, surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData,  surfaceData.geomNormalWS, surfaceData);\n                       #else\n                          DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                       #endif\n                   }\n           #endif\n        \n                   bentNormalWS = surfaceData.normalWS;\n                   // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n        \n                   surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n        \n        \n                   // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                   // If user provide bent normal then we process a better term\n           #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                   // Just use the value passed through via the slot (not active otherwise)\n           #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                   // If we have bent normal and ambient occlusion, process a specular occlusion\n                   surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n           #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                   surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n           #endif\n        \n           #ifdef _ENABLE_GEOMETRIC_SPECULAR_AA\n                   surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n           #endif\n        \n           #ifdef DEBUG_DISPLAY\n                   if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                   {\n                       // TODO: need to update mip info\n                       surfaceData.metallic = 0;\n                   }\n        \n                   // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                   // as it can modify attribute use for static lighting\n                   ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n           #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout LightingInputs l, inout ShaderData d)\n               {\n                 #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                     uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to _ScreenSize values\n                     LODDitheringTransition(fadeMaskSeed, unity_LODFade.x);\n                 #endif\n        \n                 #ifdef _DOUBLESIDED_ON\n                     float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                 #else\n                     float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                 #endif\n        \n                 ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n\n                 d = CreateShaderData(m2ps);\n\n                 l = (LightingInputs)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n\n                 ChainSurfaceFunction(l, d);\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n        \n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 builtinData.emissiveColor = l.Emission;\n        \n        \n                 #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     //builtinData.distortion = surfaceDescription.Distortion;\n                     //builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                     builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                 #else\n                     builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                 #endif\n        \n                   PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n               }\n\n            void Frag(  PackedVaryingsToPS packedInput,\n                        OUTPUT_GBUFFER(outGBuffer)\n                        #ifdef _DEPTHOFFSET_ON\n                        , out float outputDepth : SV_Depth\n                        #endif\n                        )\n            {\n                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(packedInput);\n                  FragInputs input = BuildFragInputs(packedInput.vmesh);\n\n                  // input.positionSS is SV_Position\n                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n                  #ifdef VARYINGS_NEED_POSITION_WS\n                     float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n                  #else\n                     // Unused\n                     float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0\n                  #endif\n\n                  SurfaceData surfaceData;\n                  BuiltinData builtinData;\n                  LightingInputs l;\n                  ShaderData d;\n                  GetSurfaceAndBuiltinData(packedInput.vmesh, input, V, posInput, surfaceData, builtinData, l, d);\n\n\n\n                  ENCODE_INTO_GBUFFER(surfaceData, builtinData, posInput.positionSS, outGBuffer);\n\n                  #ifdef _DEPTHOFFSET_ON\n                        outputDepth = posInput.deviceDepth;\n                  #endif\n            }\n\n            ENDHLSL\n        }\n\n               Pass\n        {\n            // based on HDLitPass.template\n            Name \"GBuffer\"\n            Tags { \"LightMode\" = \"GBuffer\" }\n        \n            //-------------------------------------------------------------------------------------\n            // Render Modes (Blend, Cull, ZTest, Stencil, etc)\n            //-------------------------------------------------------------------------------------\n            \n            Cull [_CullMode]\n        \n            ZTest [_ZTestGBuffer]\n        \n            \n            \n            // Stencil setup\n           Stencil\n           {\n              WriteMask [_StencilWriteMaskGBuffer]\n              Ref [_StencilRefGBuffer]\n              Comp Always\n              Pass Replace\n           }\n        \n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 ps4 xboxone vulkan metal switch\n            //#pragma enable_d3d11_debug_symbols\n        \n            #pragma multi_compile_instancing\n        \n            #pragma multi_compile_local _ _ALPHATEST_ON\n        \n            //#pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _DOUBLESIDED_ON\n            //#pragma shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n        \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            // #define _ENABLE_FOG_ON_TRANSPARENT 1\n            #define _AMBIENT_OCCLUSION 1\n            #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n               #pragma shader_feature_local _ _MASKMAP\n   #pragma shader_feature_local _ _DETAIL\n   #pragma shader_feature_local _ _EMISSION\n\n   #define _HDRP 1\n\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n           \n            //-------------------------------------------------------------------------------------\n            // Defines\n            //-------------------------------------------------------------------------------------\n                #define SHADERPASS SHADERPASS_GBUFFER\n                #pragma multi_compile _ DEBUG_DISPLAY\n                #pragma multi_compile _ LIGHTMAP_ON\n                #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n                #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n                #pragma multi_compile _ SHADOWS_SHADOWMASK\n                #pragma multi_compile DECALS_OFF DECALS_3RT DECALS_4RT\n                #pragma multi_compile _ LIGHT_LAYERS\n                #define RAYTRACING_SHADER_GRAPH_HIGH\n                #define REQUIRE_DEPTH_TEXTURE\n                \n        \n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler_##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler_##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler_##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler_##samp, coord)\n\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      half3 UnpackNormal(half4 packednormal)\n      {\n         half3 normal;\n         normal.xy = packednormal.wy * 2 - 1;\n         normal.z = sqrt(1 - normal.x*normal.x - normal.y * normal.y);\n         return normal;\n      }\n\n      half3 UnpackScaleNormal(half4 packednormal, half bumpScale)\n      {\n\t     #if defined(UNITY_NO_DXT5nm)\n\t        return packednormal.xyz * 2 - 1;\n\t     #else\n\t\t     half3 normal;\n\t\t     normal.xy = (packednormal.wy * 2 - 1);\n\t        #if (SHADER_TARGET >= 30)\n\t\t        normal.xy *= bumpScale;\n\t\t     #endif\n\t\t     normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n\t        return normal;\n\t     #endif\n      }\t\n\n\n// HDRP Adapter stuff\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n            #define OUTPUT_SPLIT_LIGHTING\n            #endif\n        \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n        \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n        \n            // define FragInputs structure\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n        \n\n    // We need isFontFace when using double sided\n        #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)\n            #define VARYINGS_NEED_CULLFACE\n        #endif\n        \n\n        \n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n        #ifdef DEBUG_DISPLAY\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n        #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n        \n        #if (SHADERPASS == SHADERPASS_FORWARD)\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n        \n            #define HAS_LIGHTLOOP\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n        #else\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n        #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n        \n            // Used by SceneSelectionPass\n            int _ObjectId;\n            int _PassValue;\n        \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCCOORD3;\n               float4 texcoord1 : TEXCCOORD4;\n               float4 texcoord2 : TEXCCOORD5;\n               // float4 texcoord3 : TEXCCOORD6;\n               // float4 screenPos : TEXCOORD7;\n               // float4 color : COLOR;\n\n               // float4 extraData0 : TEXCOORD8;\n               // float4 extraData1 : TEXCOORD9;\n               // float4 extraData2 : TEXCOORD10;\n               // float4 extraData3 : TEXCOORD11;\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n            };\n\n\n\n            \n            \n            // data describing the user output of a pixel\n            struct LightingInputs\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half Alpha;\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half Anisotropy;\n               half iridescenceMask;\n               half iridescenceThickness;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n\n               float3x3 TBNMatrix;\n            };\n\n            struct VertexData\n            {\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n            \n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n\n               \n               // float4 extraData0 : TEXCOORD4;\n               // float4 extraData1 : TEXCOORD5;\n               // float4 extraData2 : TEXCOORD6;\n               // float4 extraData3 : TEXCOORD7;\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraData\n            {\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), p); };\n               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), p); };\n               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }\n               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n\n               float _StencilRef;\n               float _StencilWriteMask;\n               float _StencilRefDepth;\n               float _StencilWriteMaskDepth;\n               float _StencilRefMV;\n               float _StencilWriteMaskMV;\n               float _StencilRefDistortionVec;\n               float _StencilWriteMaskDistortionVec;\n               float _StencilWriteMaskGBuffer;\n               float _StencilRefGBuffer;\n               float _ZTestGBuffer;\n               float _RequireSplitLighting;\n               float _ReceivesSSR;\n               float _ZWrite;\n               float _CullMode;\n               float _TransparentSortPriority;\n               float _CullModeForward;\n               float _TransparentCullMode;\n               float _ZTestDepthEqualForOpaque;\n               float _ZTestTransparent;\n               float _TransparentBackfaceEnable;\n               float _AlphaCutoffEnable;\n               float _UseShadowThreshold;\n               float _DoubleSidedEnable;\n               float _DoubleSidedNormalMode;\n               float4 _DoubleSidedConstants;\n\n               \thalf4 _Tint;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half _EmissionStrength;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n\n\n            CBUFFER_END\n\n            \n   half3 BlendDetailNormal(half3 n1, half3 n2)\n   {\n      return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n   }\n\n   // We share samplers with the albedo - which free's up more for stacking.\n\n   UNITY_DECLARE_TEX2D(_AlbedoMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_NormalMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_MaskMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_EmissionMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_DetailMap);\n\n\n\tvoid SurfaceFunction(inout LightingInputs o, ShaderData d)\n\t{\n      float2 uv = d.texcoord0.xy * _AlbedoMap_ST.xy + _AlbedoMap_ST.zw;\n\n      half4 c = UNITY_SAMPLE_TEX2D(_AlbedoMap, uv);\n      o.Albedo = c.rgb * _Tint.rgb;\n\t\to.Normal = UnpackScaleNormal(UNITY_SAMPLE_TEX2D_SAMPLER(_NormalMap, _AlbedoMap, uv), _NormalStrength);\n\n      half detailMask = 1;\n      #if _MASKMAP\n          // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = UNITY_SAMPLE_TEX2D_SAMPLER(_MaskMap, _AlbedoMap, uv);\n         o.Metallic = mask.r;\n         o.Occlusion = mask.g;\n         o.Smoothness = mask.a;\n         detailMask = mask.b;\n      #endif // separate maps\n\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap, _AlbedoMap, uv).rgb * _EmissionStrength;\n      #endif\n\n      #if defined(_DETAIL)\n         float2 detailUV = uv * _DetailMap_ST.xy + _DetailMap_ST.zw;\n         half4 detailSample = UNITY_SAMPLE_TEX2D_SAMPLER(_DetailMap, _AlbedoMap, detailUV);\n         o.Normal = BlendDetailNormal(o.Normal, UnpackScaleNormal(detailSample, _DetailNormalStrength * detailMask));\n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * detailSample.z, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n\n\t\to.Alpha = c.a;\n\t}\n\n\n\n        \n            void ChainSurfaceFunction(inout LightingInputs l, ShaderData d)\n            {\n                   SurfaceFunction(l, d);\n                 // SurfaceFunction_Ext1(l, d);\n                 // SurfaceFunction_Ext2(l, d);\n                 // SurfaceFunction_Ext3(l, d);\n                 // SurfaceFunction_Ext4(l, d);\n                 // SurfaceFunction_Ext5(l, d);\n                 // SurfaceFunction_Ext6(l, d);\n                 // SurfaceFunction_Ext7(l, d);\n                 // SurfaceFunction_Ext8(l, d);\n                 // SurfaceFunction_Ext9(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraData d = (ExtraData)0;\n                 //  ModifyVertex(v, d);\n                 // ModifyVertex_Ext1(v, d);\n                 // ModifyVertex_Ext2(v, d);\n                 // ModifyVertex_Ext3(v, d);\n                 // ModifyVertex_Ext4(v, d);\n                 // ModifyVertex_Ext5(v, d);\n                 // ModifyVertex_Ext6(v, d);\n                 // ModifyVertex_Ext7(v, d);\n                 // ModifyVertex_Ext8(v, d);\n                 // ModifyVertex_Ext9(v, d);\n                 // v2p.extraData0 = d.extraData0;\n                 // v2p.extraData1 = d.extraData1;\n                 // v2p.extraData2 = d.extraData2;\n                 // v2p.extraData3 = d.extraData3;\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraData d = (ExtraData)0;\n               //  ModifyTessellatedVertex(v, d);\n               // ModifyTessellatedVertex_Ext1(v, d);\n               // ModifyTessellatedVertex_Ext2(v, d);\n               // ModifyTessellatedVertex_Ext3(v, d);\n               // ModifyTessellatedVertex_Ext4(v, d);\n               // ModifyTessellatedVertex_Ext5(v, d);\n               // ModifyTessellatedVertex_Ext6(v, d);\n               // ModifyTessellatedVertex_Ext7(v, d);\n               // ModifyTessellatedVertex_Ext8(v, d);\n               // ModifyTessellatedVertex_Ext9(v, d);\n               // v2p.extraData0 = d.extraData0;\n               // v2p.extraData1 = d.extraData1;\n               // v2p.extraData2 = d.extraData2;\n               // v2p.extraData3 = d.extraData3;\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i)\n         {\n            ShaderData d = (ShaderData)0;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = i.worldNormal;\n            d.worldSpaceTangent = i.worldTangent.xyz;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n            // d.texcoord3 = i.texcoord3;\n            // d.vertexColor = i.color;\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            // d.localSpacePosition = mul(GetWorldToObjectMatrix(), i.worldPos);\n            // d.localSpaceNormal = mul(GetWorldToObjectMatrix(), i.worldNormal);\n            // d.localSpaceTangent = mul(GetWorldToObjectMatrix(), i.worldTangent.xyz);\n\n            // d.screenPos = i.screenPos;\n            // d.screenUV = i.screenPos.xy / i.screenPos.w;\n\n            // d.extraData0 = i.extraData0;\n            // d.extraData1 = i.extraData1;\n            // d.extraData2 = i.extraData2;\n            // d.extraData3 = i.extraData3;\n\n            return d;\n         }\n         \n\n            \n\nstruct VaryingsToPS\n{\n   VertexToPixel vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      VaryingsPassToPS vpass;\n   #endif\n};\n\nstruct PackedVaryingsToPS\n{\n   #ifdef VARYINGS_NEED_PASS\n      PackedVaryingsPassToPS vpass;\n   #endif\n   VertexToPixel vmesh;\n\n   UNITY_VERTEX_OUTPUT_STEREO\n};\n\nPackedVaryingsToPS PackVaryingsToPS(VaryingsToPS input)\n{\n   PackedVaryingsToPS output = (PackedVaryingsToPS)0;\n   output.vmesh = input.vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      output.vpass = PackVaryingsPassToPS(input.vpass);\n   #endif\n\n   UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n   return output;\n}\n\n\n\n\nVertexToPixel VertMesh(VertexData input)\n{\n    VertexToPixel output = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(input);\n    UNITY_TRANSFER_INSTANCE_ID(input, output);\n\n    \n    ChainModifyVertex(input, output);\n\n\n    // This return the camera relative position (if enable)\n    float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n    float3 normalWS = TransformObjectToWorldNormal(input.normal);\n    float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n    output.worldPos = positionRWS;\n    output.pos = TransformWorldToHClip(positionRWS);\n    output.worldNormal = normalWS;\n    output.worldTangent = tangentWS;\n\n\n    output.texcoord0 = input.texcoord0;\n    output.texcoord1 = input.texcoord1;\n    output.texcoord2 = input.texcoord2;\n    // output.texcoord3 = input.texcoord3;\n    // output.color = input.color;\n\n    return output;\n}\n\n\n#if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\nvoid MeshDecalsPositionZBias(inout VaryingsToPS input)\n{\n#if defined(UNITY_REVERSED_Z)\n    input.vmesh.pos.z -= _DecalMeshDepthBias;\n#else\n    input.vmesh.pos.z += _DecalMeshDepthBias;\n#endif\n}\n#endif\n\n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n// This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\nfloat unity_OneOverOutputBoost;\nfloat unity_MaxOutputValue;\n\nCBUFFER_START(UnityMetaPass)\n// x = use uv1 as raster position\n// y = use uv2 as raster position\nbool4 unity_MetaVertexControl;\n\n// x = return albedo\n// y = return normal\nbool4 unity_MetaFragmentControl;\nCBUFFER_END\n\nPackedVaryingsToPS Vert(VertexData inputMesh)\n{\n    VaryingsToPS output = (VaryingsToPS)0;\n    output.vmesh = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(inputMesh);\n    UNITY_TRANSFER_INSTANCE_ID(inputMesh, output.vmesh);\n\n    // Output UV coordinate in vertex shader\n    float2 uv = float2(0.0, 0.0);\n\n    if (unity_MetaVertexControl.x)\n    {\n        uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n    }\n    else if (unity_MetaVertexControl.y)\n    {\n        uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n    }\n\n    // OpenGL right now needs to actually use the incoming vertex position\n    // so we create a fake dependency on it here that haven't any impact.\n    output.vmesh.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n#ifdef VARYINGS_NEED_POSITION_WS\n    output.vmesh.worldPos = TransformObjectToWorld(inputMesh.vertex);\n#endif\n\n#ifdef VARYINGS_NEED_TANGENT_TO_WORLD\n    // Normal is required for triplanar mapping\n    output.vmesh.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n    // Not required but assign to silent compiler warning\n    output.vmesh.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n#endif\n\n    output.vmesh.texcoord0 = inputMesh.texcoord0;\n    output.vmesh.texcoord1 = inputMesh.texcoord1;\n    output.vmesh.texcoord2 = inputMesh.texcoord2;\n    // output.vmesh.texCoord3 = inputMesh.texcoord3;\n    // output.vmesh.color = inputMesh.color;\n\n    return PackVaryingsToPS(output);\n}\n#else\n\nPackedVaryingsToPS Vert(VertexData inputMesh)\n{\n    VaryingsToPS varyingsType;\n    varyingsType.vmesh = VertMesh(inputMesh);\n    #if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\n       MeshDecalsPositionZBias(varyingsType);\n    #endif\n    return PackVaryingsToPS(varyingsType);\n}\n\n#endif\n\n\n\n            \n\n            \n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n            \n                    output.positionRWS = input.worldPos;\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n                    //output.color = input.color;\n                    //#if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                    //output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                    //#elif SHADER_STAGE_FRAGMENT\n                    // output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                    //#endif // SHADER_STAGE_FRAGMENT\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout LightingInputs surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n        \n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n        \n           #ifdef _HAS_REFRACTION\n                   if (_EnableSSRefraction)\n                   {\n                       // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                       // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                       // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n        \n                       surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                       surfaceDescription.Alpha = 1.0;\n                   }\n                   else\n                   {\n                       surfaceData.ior = 1.0;\n                       surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                       surfaceData.atDistance = 1.0;\n                       surfaceData.transmittanceMask = 0.0;\n                       surfaceDescription.Alpha = 1.0;\n                   }\n           #else\n                   surfaceData.ior = 1.0;\n                   surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                   surfaceData.atDistance = 1.0;\n                   surfaceData.transmittanceMask = 0.0;\n           #endif\n                \n                   // These static material feature allow compile time optimization\n                   surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n           #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n           #endif\n           #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n           #endif\n           #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n           #endif\n                   // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n        \n           #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n           #endif\n           #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n           #endif\n        \n           #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                   // Require to have setup baseColor\n                   // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                   surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n           #endif\n        \n           #ifdef _DOUBLESIDED_ON\n               float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n           #else\n               float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n           #endif\n        \n                   // tangent-space normal\n                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                   normalTS = surfaceDescription.Normal;\n        \n                   // compute world space normal\n                   GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n        \n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                   // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent, fragInputs.tangentToWorld);\n        \n           #if HAVE_DECALS\n                   if (_EnableDecals)\n                   {\n                       #if VERSION_GREATER_EQUAL(10,2)\n                          DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput,  surfaceData.geomNormalWS, surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData,  surfaceData.geomNormalWS, surfaceData);\n                       #else\n                          DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                       #endif\n                   }\n           #endif\n        \n                   bentNormalWS = surfaceData.normalWS;\n                   // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n        \n                   surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n        \n        \n                   // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                   // If user provide bent normal then we process a better term\n           #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                   // Just use the value passed through via the slot (not active otherwise)\n           #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                   // If we have bent normal and ambient occlusion, process a specular occlusion\n                   surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n           #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                   surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n           #endif\n        \n           #ifdef _ENABLE_GEOMETRIC_SPECULAR_AA\n                   surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n           #endif\n        \n           #ifdef DEBUG_DISPLAY\n                   if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                   {\n                       // TODO: need to update mip info\n                       surfaceData.metallic = 0;\n                   }\n        \n                   // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                   // as it can modify attribute use for static lighting\n                   ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n           #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout LightingInputs l, inout ShaderData d)\n               {\n                 #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                     uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to _ScreenSize values\n                     LODDitheringTransition(fadeMaskSeed, unity_LODFade.x);\n                 #endif\n        \n                 #ifdef _DOUBLESIDED_ON\n                     float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                 #else\n                     float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                 #endif\n        \n                 ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n\n                 d = CreateShaderData(m2ps);\n\n                 l = (LightingInputs)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n\n                 ChainSurfaceFunction(l, d);\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n        \n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 builtinData.emissiveColor = l.Emission;\n        \n        \n                 #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     //builtinData.distortion = surfaceDescription.Distortion;\n                     //builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                     builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                 #else\n                     builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                 #endif\n        \n                   PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n               }\n\n            void Frag(  PackedVaryingsToPS packedInput,\n                        OUTPUT_GBUFFER(outGBuffer)\n                        #ifdef _DEPTHOFFSET_ON\n                        , out float outputDepth : SV_Depth\n                        #endif\n                        )\n            {\n                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(packedInput);\n                  FragInputs input = BuildFragInputs(packedInput.vmesh);\n\n                  // input.positionSS is SV_Position\n                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n                  #ifdef VARYINGS_NEED_POSITION_WS\n                     float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n                  #else\n                     // Unused\n                     float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0\n                  #endif\n\n                  SurfaceData surfaceData;\n                  BuiltinData builtinData;\n                  LightingInputs l;\n                  ShaderData d;\n                  GetSurfaceAndBuiltinData(packedInput.vmesh, input, V, posInput, surfaceData, builtinData, l, d);\n\n                  ENCODE_INTO_GBUFFER(surfaceData, builtinData, posInput.positionSS, outGBuffer);\n\n                  #ifdef _DEPTHOFFSET_ON\n                        outputDepth = posInput.deviceDepth;\n                  #endif\n            }\n\n            ENDHLSL\n        }\n        \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"Forward\"\n            Tags { \"LightMode\" = \"Forward\" }\n\n            \n        \n            \n            // Stencil setup\n        Stencil\n        {\n           WriteMask [_StencilWriteMask]\n           Ref [_StencilRef]\n           Comp Always\n           Pass Replace\n        }\n        \n            ColorMask [_ColorMaskTransparentVel] 1\n        \n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 ps4 xboxone vulkan metal switch\n            //#pragma enable_d3d11_debug_symbols\n        \n            #pragma multi_compile_instancing\n        \n            #pragma multi_compile_local _ _ALPHATEST_ON\n        \n            // #pragma multi_compile _ LOD_FADE_CROSSFADE\n        \n            //#pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _DOUBLESIDED_ON\n            //#pragma shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n        \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            // #define _ENABLE_FOG_ON_TRANSPARENT 1\n            #define _AMBIENT_OCCLUSION 1\n            #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            \n               #pragma shader_feature_local _ _MASKMAP\n   #pragma shader_feature_local _ _DETAIL\n   #pragma shader_feature_local _ _EMISSION\n\n   #define _HDRP 1\n\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #define SHADERPASS SHADERPASS_FORWARD\n            #pragma multi_compile _ DEBUG_DISPLAY\n            #pragma multi_compile _ LIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n            #pragma multi_compile _ SHADOWS_SHADOWMASK\n            #pragma multi_compile DECALS_OFF DECALS_3RT DECALS_4RT\n            #pragma multi_compile USE_FPTL_LIGHTLIST USE_CLUSTERED_LIGHTLIST\n            #pragma multi_compile SHADOW_LOW SHADOW_MEDIUM SHADOW_HIGH\n            #define REQUIRE_DEPTH_TEXTURE\n            \n\n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler_##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler_##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler_##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler_##samp, coord)\n\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      half3 UnpackNormal(half4 packednormal)\n      {\n         half3 normal;\n         normal.xy = packednormal.wy * 2 - 1;\n         normal.z = sqrt(1 - normal.x*normal.x - normal.y * normal.y);\n         return normal;\n      }\n\n      half3 UnpackScaleNormal(half4 packednormal, half bumpScale)\n      {\n\t     #if defined(UNITY_NO_DXT5nm)\n\t        return packednormal.xyz * 2 - 1;\n\t     #else\n\t\t     half3 normal;\n\t\t     normal.xy = (packednormal.wy * 2 - 1);\n\t        #if (SHADER_TARGET >= 30)\n\t\t        normal.xy *= bumpScale;\n\t\t     #endif\n\t\t     normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n\t        return normal;\n\t     #endif\n      }\t\n\n\n// HDRP Adapter stuff\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n            #define OUTPUT_SPLIT_LIGHTING\n            #endif\n        \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n        \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n        \n            // define FragInputs structure\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n        \n\n    // We need isFontFace when using double sided\n        #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)\n            #define VARYINGS_NEED_CULLFACE\n        #endif\n        \n\n        \n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n        #ifdef DEBUG_DISPLAY\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n        #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n        \n        #if (SHADERPASS == SHADERPASS_FORWARD)\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n        \n            #define HAS_LIGHTLOOP\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n        #else\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n        #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n        \n            // Used by SceneSelectionPass\n            int _ObjectId;\n            int _PassValue;\n        \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCCOORD3;\n               float4 texcoord1 : TEXCCOORD4;\n               float4 texcoord2 : TEXCCOORD5;\n               // float4 texcoord3 : TEXCCOORD6;\n               // float4 screenPos : TEXCOORD7;\n               // float4 color : COLOR;\n\n               // float4 extraData0 : TEXCOORD8;\n               // float4 extraData1 : TEXCOORD9;\n               // float4 extraData2 : TEXCOORD10;\n               // float4 extraData3 : TEXCOORD11;\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n            };\n\n\n\n            \n            \n            // data describing the user output of a pixel\n            struct LightingInputs\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half Alpha;\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half Anisotropy;\n               half iridescenceMask;\n               half iridescenceThickness;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n\n               float3x3 TBNMatrix;\n            };\n\n            struct VertexData\n            {\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n            \n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n\n               \n               // float4 extraData0 : TEXCOORD4;\n               // float4 extraData1 : TEXCOORD5;\n               // float4 extraData2 : TEXCOORD6;\n               // float4 extraData3 : TEXCOORD7;\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraData\n            {\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), p); };\n               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), p); };\n               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }\n               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n\n               float _StencilRef;\n               float _StencilWriteMask;\n               float _StencilRefDepth;\n               float _StencilWriteMaskDepth;\n               float _StencilRefMV;\n               float _StencilWriteMaskMV;\n               float _StencilRefDistortionVec;\n               float _StencilWriteMaskDistortionVec;\n               float _StencilWriteMaskGBuffer;\n               float _StencilRefGBuffer;\n               float _ZTestGBuffer;\n               float _RequireSplitLighting;\n               float _ReceivesSSR;\n               float _ZWrite;\n               float _CullMode;\n               float _TransparentSortPriority;\n               float _CullModeForward;\n               float _TransparentCullMode;\n               float _ZTestDepthEqualForOpaque;\n               float _ZTestTransparent;\n               float _TransparentBackfaceEnable;\n               float _AlphaCutoffEnable;\n               float _UseShadowThreshold;\n               float _DoubleSidedEnable;\n               float _DoubleSidedNormalMode;\n               float4 _DoubleSidedConstants;\n\n               \thalf4 _Tint;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half _EmissionStrength;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n\n\n            CBUFFER_END\n\n            \n   half3 BlendDetailNormal(half3 n1, half3 n2)\n   {\n      return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n   }\n\n   // We share samplers with the albedo - which free's up more for stacking.\n\n   UNITY_DECLARE_TEX2D(_AlbedoMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_NormalMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_MaskMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_EmissionMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_DetailMap);\n\n\n\tvoid SurfaceFunction(inout LightingInputs o, ShaderData d)\n\t{\n      float2 uv = d.texcoord0.xy * _AlbedoMap_ST.xy + _AlbedoMap_ST.zw;\n\n      half4 c = UNITY_SAMPLE_TEX2D(_AlbedoMap, uv);\n      o.Albedo = c.rgb * _Tint.rgb;\n\t\to.Normal = UnpackScaleNormal(UNITY_SAMPLE_TEX2D_SAMPLER(_NormalMap, _AlbedoMap, uv), _NormalStrength);\n\n      half detailMask = 1;\n      #if _MASKMAP\n          // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = UNITY_SAMPLE_TEX2D_SAMPLER(_MaskMap, _AlbedoMap, uv);\n         o.Metallic = mask.r;\n         o.Occlusion = mask.g;\n         o.Smoothness = mask.a;\n         detailMask = mask.b;\n      #endif // separate maps\n\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap, _AlbedoMap, uv).rgb * _EmissionStrength;\n      #endif\n\n      #if defined(_DETAIL)\n         float2 detailUV = uv * _DetailMap_ST.xy + _DetailMap_ST.zw;\n         half4 detailSample = UNITY_SAMPLE_TEX2D_SAMPLER(_DetailMap, _AlbedoMap, detailUV);\n         o.Normal = BlendDetailNormal(o.Normal, UnpackScaleNormal(detailSample, _DetailNormalStrength * detailMask));\n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * detailSample.z, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n\n\t\to.Alpha = c.a;\n\t}\n\n\n\n        \n            void ChainSurfaceFunction(inout LightingInputs l, ShaderData d)\n            {\n                   SurfaceFunction(l, d);\n                 // SurfaceFunction_Ext1(l, d);\n                 // SurfaceFunction_Ext2(l, d);\n                 // SurfaceFunction_Ext3(l, d);\n                 // SurfaceFunction_Ext4(l, d);\n                 // SurfaceFunction_Ext5(l, d);\n                 // SurfaceFunction_Ext6(l, d);\n                 // SurfaceFunction_Ext7(l, d);\n                 // SurfaceFunction_Ext8(l, d);\n                 // SurfaceFunction_Ext9(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraData d = (ExtraData)0;\n                 //  ModifyVertex(v, d);\n                 // ModifyVertex_Ext1(v, d);\n                 // ModifyVertex_Ext2(v, d);\n                 // ModifyVertex_Ext3(v, d);\n                 // ModifyVertex_Ext4(v, d);\n                 // ModifyVertex_Ext5(v, d);\n                 // ModifyVertex_Ext6(v, d);\n                 // ModifyVertex_Ext7(v, d);\n                 // ModifyVertex_Ext8(v, d);\n                 // ModifyVertex_Ext9(v, d);\n                 // v2p.extraData0 = d.extraData0;\n                 // v2p.extraData1 = d.extraData1;\n                 // v2p.extraData2 = d.extraData2;\n                 // v2p.extraData3 = d.extraData3;\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraData d = (ExtraData)0;\n               //  ModifyTessellatedVertex(v, d);\n               // ModifyTessellatedVertex_Ext1(v, d);\n               // ModifyTessellatedVertex_Ext2(v, d);\n               // ModifyTessellatedVertex_Ext3(v, d);\n               // ModifyTessellatedVertex_Ext4(v, d);\n               // ModifyTessellatedVertex_Ext5(v, d);\n               // ModifyTessellatedVertex_Ext6(v, d);\n               // ModifyTessellatedVertex_Ext7(v, d);\n               // ModifyTessellatedVertex_Ext8(v, d);\n               // ModifyTessellatedVertex_Ext9(v, d);\n               // v2p.extraData0 = d.extraData0;\n               // v2p.extraData1 = d.extraData1;\n               // v2p.extraData2 = d.extraData2;\n               // v2p.extraData3 = d.extraData3;\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i)\n         {\n            ShaderData d = (ShaderData)0;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = i.worldNormal;\n            d.worldSpaceTangent = i.worldTangent.xyz;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n            // d.texcoord3 = i.texcoord3;\n            // d.vertexColor = i.color;\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            // d.localSpacePosition = mul(GetWorldToObjectMatrix(), i.worldPos);\n            // d.localSpaceNormal = mul(GetWorldToObjectMatrix(), i.worldNormal);\n            // d.localSpaceTangent = mul(GetWorldToObjectMatrix(), i.worldTangent.xyz);\n\n            // d.screenPos = i.screenPos;\n            // d.screenUV = i.screenPos.xy / i.screenPos.w;\n\n            // d.extraData0 = i.extraData0;\n            // d.extraData1 = i.extraData1;\n            // d.extraData2 = i.extraData2;\n            // d.extraData3 = i.extraData3;\n\n            return d;\n         }\n         \n\n            \n\nstruct VaryingsToPS\n{\n   VertexToPixel vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      VaryingsPassToPS vpass;\n   #endif\n};\n\nstruct PackedVaryingsToPS\n{\n   #ifdef VARYINGS_NEED_PASS\n      PackedVaryingsPassToPS vpass;\n   #endif\n   VertexToPixel vmesh;\n\n   UNITY_VERTEX_OUTPUT_STEREO\n};\n\nPackedVaryingsToPS PackVaryingsToPS(VaryingsToPS input)\n{\n   PackedVaryingsToPS output = (PackedVaryingsToPS)0;\n   output.vmesh = input.vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      output.vpass = PackVaryingsPassToPS(input.vpass);\n   #endif\n\n   UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n   return output;\n}\n\n\n\n\nVertexToPixel VertMesh(VertexData input)\n{\n    VertexToPixel output = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(input);\n    UNITY_TRANSFER_INSTANCE_ID(input, output);\n\n    \n    ChainModifyVertex(input, output);\n\n\n    // This return the camera relative position (if enable)\n    float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n    float3 normalWS = TransformObjectToWorldNormal(input.normal);\n    float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n    output.worldPos = positionRWS;\n    output.pos = TransformWorldToHClip(positionRWS);\n    output.worldNormal = normalWS;\n    output.worldTangent = tangentWS;\n\n\n    output.texcoord0 = input.texcoord0;\n    output.texcoord1 = input.texcoord1;\n    output.texcoord2 = input.texcoord2;\n    // output.texcoord3 = input.texcoord3;\n    // output.color = input.color;\n\n    return output;\n}\n\n\n#if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\nvoid MeshDecalsPositionZBias(inout VaryingsToPS input)\n{\n#if defined(UNITY_REVERSED_Z)\n    input.vmesh.pos.z -= _DecalMeshDepthBias;\n#else\n    input.vmesh.pos.z += _DecalMeshDepthBias;\n#endif\n}\n#endif\n\n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n// This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\nfloat unity_OneOverOutputBoost;\nfloat unity_MaxOutputValue;\n\nCBUFFER_START(UnityMetaPass)\n// x = use uv1 as raster position\n// y = use uv2 as raster position\nbool4 unity_MetaVertexControl;\n\n// x = return albedo\n// y = return normal\nbool4 unity_MetaFragmentControl;\nCBUFFER_END\n\nPackedVaryingsToPS Vert(VertexData inputMesh)\n{\n    VaryingsToPS output = (VaryingsToPS)0;\n    output.vmesh = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(inputMesh);\n    UNITY_TRANSFER_INSTANCE_ID(inputMesh, output.vmesh);\n\n    // Output UV coordinate in vertex shader\n    float2 uv = float2(0.0, 0.0);\n\n    if (unity_MetaVertexControl.x)\n    {\n        uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n    }\n    else if (unity_MetaVertexControl.y)\n    {\n        uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n    }\n\n    // OpenGL right now needs to actually use the incoming vertex position\n    // so we create a fake dependency on it here that haven't any impact.\n    output.vmesh.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n#ifdef VARYINGS_NEED_POSITION_WS\n    output.vmesh.worldPos = TransformObjectToWorld(inputMesh.vertex);\n#endif\n\n#ifdef VARYINGS_NEED_TANGENT_TO_WORLD\n    // Normal is required for triplanar mapping\n    output.vmesh.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n    // Not required but assign to silent compiler warning\n    output.vmesh.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n#endif\n\n    output.vmesh.texcoord0 = inputMesh.texcoord0;\n    output.vmesh.texcoord1 = inputMesh.texcoord1;\n    output.vmesh.texcoord2 = inputMesh.texcoord2;\n    // output.vmesh.texCoord3 = inputMesh.texcoord3;\n    // output.vmesh.color = inputMesh.color;\n\n    return PackVaryingsToPS(output);\n}\n#else\n\nPackedVaryingsToPS Vert(VertexData inputMesh)\n{\n    VaryingsToPS varyingsType;\n    varyingsType.vmesh = VertMesh(inputMesh);\n    #if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\n       MeshDecalsPositionZBias(varyingsType);\n    #endif\n    return PackVaryingsToPS(varyingsType);\n}\n\n#endif\n\n\n\n            \n\n            \n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n            \n                    output.positionRWS = input.worldPos;\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n                    //output.color = input.color;\n                    //#if _DOUBLESIDED_ON && SHADER_STAGE_FRAGMENT\n                    //output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                    //#elif SHADER_STAGE_FRAGMENT\n                    // output.isFrontFace = IS_FRONT_VFACE(input.cullFace, true, false);\n                    //#endif // SHADER_STAGE_FRAGMENT\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout LightingInputs surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n        \n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   // surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n        \n           #ifdef _HAS_REFRACTION\n                   if (_EnableSSRefraction)\n                   {\n                       // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                       // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                       // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n        \n                       surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                       surfaceDescription.Alpha = 1.0;\n                   }\n                   else\n                   {\n                       surfaceData.ior = 1.0;\n                       surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                       surfaceData.atDistance = 1.0;\n                       surfaceData.transmittanceMask = 0.0;\n                       surfaceDescription.Alpha = 1.0;\n                   }\n           #else\n                   surfaceData.ior = 1.0;\n                   surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                   surfaceData.atDistance = 1.0;\n                   surfaceData.transmittanceMask = 0.0;\n           #endif\n                \n                   // These static material feature allow compile time optimization\n                   surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n           #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n           #endif\n           #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n           #endif\n           #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n           #endif\n                   // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n        \n           #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n           #endif\n           #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                   surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n           #endif\n        \n           #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                   // Require to have setup baseColor\n                   // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                   surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n           #endif\n        \n           #ifdef _DOUBLESIDED_ON\n               float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n           #else\n               float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n           #endif\n        \n                   // tangent-space normal\n                   float3 normalTS = float3(0.0f, 0.0f, 1.0f);\n                   normalTS = surfaceDescription.Normal;\n        \n                   // compute world space normal\n                   GetNormalWS(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n        \n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                   // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent, fragInputs.tangentToWorld);\n        \n           #if HAVE_DECALS\n                   if (_EnableDecals)\n                   {\n                       #if VERSION_GREATER_EQUAL(10,2)\n                          DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput,  surfaceData.geomNormalWS, surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData,  surfaceData.geomNormalWS, surfaceData);\n                       #else\n                          DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                       #endif\n                   }\n           #endif\n        \n                   bentNormalWS = surfaceData.normalWS;\n                   // GetNormalWS(fragInputs, surfaceDescription.BentNormal, bentNormalWS, doubleSidedConstants);\n        \n                   surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n        \n        \n                   // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                   // If user provide bent normal then we process a better term\n           #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                   // Just use the value passed through via the slot (not active otherwise)\n           #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                   // If we have bent normal and ambient occlusion, process a specular occlusion\n                   surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n           #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                   surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n           #endif\n        \n           #ifdef _ENABLE_GEOMETRIC_SPECULAR_AA\n                   surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n           #endif\n        \n           #ifdef DEBUG_DISPLAY\n                   if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                   {\n                       // TODO: need to update mip info\n                       surfaceData.metallic = 0;\n                   }\n        \n                   // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                   // as it can modify attribute use for static lighting\n                   ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n           #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout LightingInputs l, inout ShaderData d)\n               {\n                 #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                     uint3 fadeMaskSeed = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to _ScreenSize values\n                     LODDitheringTransition(fadeMaskSeed, unity_LODFade.x);\n                 #endif\n        \n                 #ifdef _DOUBLESIDED_ON\n                     float3 doubleSidedConstants = _DoubleSidedConstants.xyz;\n                 #else\n                     float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);\n                 #endif\n        \n                 ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants);\n\n                 d = CreateShaderData(m2ps);\n\n                 l = (LightingInputs)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n\n                 ChainSurfaceFunction(l, d);\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n        \n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -fragInputs.tangentToWorld[2], fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 builtinData.emissiveColor = l.Emission;\n        \n        \n                 #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     //builtinData.distortion = surfaceDescription.Distortion;\n                     //builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                     builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                 #else\n                     builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                 #endif\n        \n                   PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n               }\n            \n                      \n          void Frag(PackedVaryingsToPS packedInput,\n          #ifdef OUTPUT_SPLIT_LIGHTING\n              out float4 outColor : SV_Target0,  // outSpecularLighting\n              out float4 outDiffuseLighting : SV_Target1,\n              OUTPUT_SSSBUFFER(outSSSBuffer)\n          #else\n              out float4 outColor : SV_Target0\n          #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n              , out float4 outMotionVec : SV_Target1\n          #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n          #endif // OUTPUT_SPLIT_LIGHTING\n          #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n          #endif\n          )\n          {\n          #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n              // Init outMotionVector here to solve compiler warning (potentially unitialized variable)\n              // It is init to the value of forceNoMotion (with 2.0)\n              outMotionVec = float4(2.0, 0.0, 0.0, 0.0);\n          #endif\n\n              UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(packedInput);\n              FragInputs input = BuildFragInputs(packedInput.vmesh);\n\n              // We need to readapt the SS position as our screen space positions are for a low res buffer, but we try to access a full res buffer.\n              input.positionSS.xy = _OffScreenRendering > 0 ? (input.positionSS.xy * _OffScreenDownsampleFactor) : input.positionSS.xy;\n\n              uint2 tileIndex = uint2(input.positionSS.xy) / GetTileSize();\n\n              // input.positionSS is SV_Position\n              PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS.xyz, tileIndex);\n\n              #ifdef VARYINGS_NEED_POSITION_WS\n                 float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n              #else\n                 // Unused\n                 float3 V = float3(1.0, 1.0, 1.0); // Avoid the division by 0\n              #endif\n\n              SurfaceData surfaceData;\n              BuiltinData builtinData;\n              LightingInputs l;\n              ShaderData d;\n              GetSurfaceAndBuiltinData(packedInput.vmesh, input, V, posInput, surfaceData, builtinData, l, d);\n\n\n              BSDFData bsdfData = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);\n\n              PreLightData preLightData = GetPreLightData(V, posInput, bsdfData);\n\n              outColor = float4(0.0, 0.0, 0.0, 0.0);\n\n              // We need to skip lighting when doing debug pass because the debug pass is done before lighting so some buffers may not be properly initialized potentially causing crashes on PS4.\n\n          #ifdef DEBUG_DISPLAY\n              // Init in debug display mode to quiet warning\n          #ifdef OUTPUT_SPLIT_LIGHTING\n              outDiffuseLighting = 0;\n              ENCODE_INTO_SSSBUFFER(surfaceData, posInput.positionSS, outSSSBuffer);\n          #endif\n\n              \n\n              // Same code in ShaderPassForwardUnlit.shader\n              // Reminder: _DebugViewMaterialArray[i]\n              //   i==0 -> the size used in the buffer\n              //   i>0  -> the index used (0 value means nothing)\n              // The index stored in this buffer could either be\n              //   - a gBufferIndex (always stored in _DebugViewMaterialArray[1] as only one supported)\n              //   - a property index which is different for each kind of material even if reflecting the same thing (see MaterialSharedProperty)\n              bool viewMaterial = false;\n              int bufferSize = int(_DebugViewMaterialArray[0]);\n              if (bufferSize != 0)\n              {\n                  bool needLinearToSRGB = false;\n                  float3 result = float3(1.0, 0.0, 1.0);\n\n                  // Loop through the whole buffer\n                  // Works because GetSurfaceDataDebug will do nothing if the index is not a known one\n                  for (int index = 1; index <= bufferSize; index++)\n                  {\n                      int indexMaterialProperty = int(_DebugViewMaterialArray[index]);\n\n                      // skip if not really in use\n                      if (indexMaterialProperty != 0)\n                      {\n                          viewMaterial = true;\n\n                          GetPropertiesDataDebug(indexMaterialProperty, result, needLinearToSRGB);\n                          GetVaryingsDataDebug(indexMaterialProperty, input, result, needLinearToSRGB);\n                          GetBuiltinDataDebug(indexMaterialProperty, builtinData, result, needLinearToSRGB);\n                          GetSurfaceDataDebug(indexMaterialProperty, surfaceData, result, needLinearToSRGB);\n                          GetBSDFDataDebug(indexMaterialProperty, bsdfData, result, needLinearToSRGB);\n                      }\n                  }\n\n                  // TEMP!\n                  // For now, the final blit in the backbuffer performs an sRGB write\n                  // So in the meantime we apply the inverse transform to linear data to compensate.\n                  if (!needLinearToSRGB)\n                      result = SRGBToLinear(max(0, result));\n\n                  outColor = float4(result, 1.0);\n              }\n\n              if (!viewMaterial)\n              {\n                  if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_VALIDATE_DIFFUSE_COLOR || _DebugFullScreenMode == FULLSCREENDEBUGMODE_VALIDATE_SPECULAR_COLOR)\n                  {\n                      float3 result = float3(0.0, 0.0, 0.0);\n\n                      GetPBRValidatorDebug(surfaceData, result);\n\n                      outColor = float4(result, 1.0f);\n                  }\n                  else if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_TRANSPARENCY_OVERDRAW)\n                  {\n                      float4 result = _DebugTransparencyOverdrawWeight * float4(TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_A);\n                      outColor = result;\n                  }\n                  else\n          #endif\n                  {\n          #ifdef _SURFACE_TYPE_TRANSPARENT\n                      uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_TRANSPARENT;\n          #else\n                      uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_OPAQUE;\n          #endif\n\n                      float3 diffuseLighting;\n                      float3 specularLighting;\n\n                      #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                      {\n                         LightLoopOutput lightLoopOutput;\n                         LightLoop(V, posInput, preLightData, bsdfData, builtinData, featureFlags, lightLoopOutput);\n\n                         // Alias\n                         diffuseLighting = lightLoopOutput.diffuseLighting;\n                         specularLighting = lightLoopOutput.specularLighting;\n                      }\n                      #else\n                      {\n                         LightLoop(V, posInput, preLightData, bsdfData, builtinData, featureFlags, diffuseLighting, specularLighting);\n                      }\n                      #endif\n\n                      diffuseLighting *= GetCurrentExposureMultiplier();\n                      specularLighting *= GetCurrentExposureMultiplier();\n\n          #ifdef OUTPUT_SPLIT_LIGHTING\n                      if (_EnableSubsurfaceScattering != 0 && ShouldOutputSplitLighting(bsdfData))\n                      {\n                          outColor = float4(specularLighting, 1.0);\n                          outDiffuseLighting = float4(TagLightingForSSS(diffuseLighting), 1.0);\n                      }\n                      else\n                      {\n                          outColor = float4(diffuseLighting + specularLighting, 1.0);\n                          outDiffuseLighting = 0;\n                      }\n                      ENCODE_INTO_SSSBUFFER(surfaceData, posInput.positionSS, outSSSBuffer);\n          #else\n                      outColor = ApplyBlendMode(diffuseLighting, specularLighting, builtinData.opacity);\n                      outColor = EvaluateAtmosphericScattering(posInput, V, outColor);\n          #endif\n\n          // FinalColorForward(l, d, outColor);\n\n          #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n                      VaryingsPassToPS inputPass = UnpackVaryingsPassToPS(packedInput.vpass);\n                      bool forceNoMotion = any(unity_MotionVectorsParams.yw == 0.0);\n                      // outMotionVec is already initialize at the value of forceNoMotion (see above)\n                      if (!forceNoMotion)\n                      {\n                          float2 motionVec = CalculateMotionVector(inputPass.positionCS, inputPass.previousPositionCS);\n                          EncodeMotionVector(motionVec * 0.5, outMotionVec);\n                          outMotionVec.zw = 1.0;\n                      }\n          #endif\n                  }\n\n          #ifdef DEBUG_DISPLAY\n              }\n          #endif\n\n          #ifdef _DEPTHOFFSET_ON\n              outputDepth = posInput.deviceDepth;\n          #endif\n          }\n\n            ENDHLSL\n        }\n\n      \n\n   }\n   \n   \n}\n"},{"srpTarget":1,"UnityVersionMin":20194,"UnityVersionMax":30000,"shader":{"fileID":4800000,"guid":"272aa2dcdb1304f16a9e288dc6ec61f8","type":3},"shaderSrc":"Shader \"BetterShaders/Standard\"\n{\n   Properties\n   {\n         _AlbedoMap(\"Albedo\", 2D) = \"white\" {}\n\t_Tint (\"Tint\", Color) = (1, 1, 1, 1)\n   \n   [Normal][NoScaleOffset]_NormalMap(\"Normal\", 2D) = \"bump\" {}\n   _NormalStrength(\"Normal Strength\", Range(0,2)) = 1\n\n   [Toggle(_MASKMAP)]\n   _UseMaskMap (\"Use Mask Map\", Float) = 0\n   [NoScaleOffset]_MaskMap(\"Mask Map\", 2D) = \"black\" {}\n\n   [Toggle(_EMISSION)]\n   _UseEmission (\"Use Emission Map\", Float) = 0\n   [NoScaleOffset]_EmissionMap(\"Emission Map\", 2D) = \"black\" {}\n   _EmissionStrength(\"Emission Strength\", Range(0, 4)) = 1\n\n   [Toggle(_DETAIL)]\n   _UseDetail(\"Use Detail Map\", Float) = 0\n   _DetailMap(\"Detail Map\", 2D) = \"bump\" {}\n   _DetailAlbedoStrength(\"Detail Albedo Strength\", Range(0, 2)) = 1\n   _DetailNormalStrength(\"Detail Normal Strength\", Range(0, 2)) = 1\n   _DetailSmoothnessStrength(\"Detail Smoothness Strength\", Range(0, 2)) = 1\n\n\n   }\n   SubShader\n   {\n      Tags { \"RenderPipeline\"=\"UniversalPipeline\" \"RenderType\" = \"Opaque\" \"Queue\" = \"Geometry\" }\n\n      \n        Pass\n        {\n            Name \"Universal Forward\"\n            Tags \n            { \n                \"LightMode\" = \"UniversalForward\"\n            }\n            Blend One Zero, One Zero\nCull Back\nZTest LEqual\nZWrite On\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_fog\n            #pragma multi_compile_instancing\n        \n            // Keywords\n            #pragma multi_compile _ LIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS\n            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE\n            #pragma multi_compile _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS _ADDITIONAL_OFF\n            #pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS\n            #pragma multi_compile _ _SHADOWS_SOFT\n            #pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE\n            // GraphKeywords: <None>\n            \n\n                 \n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n        \n\n            #pragma shader_feature_local _ _MASKMAP\n   #pragma shader_feature_local _ _DETAIL\n   #pragma shader_feature_local _ _EMISSION\n\n   #define _URP 1\n\n\n               #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler_##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler_##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler_##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler_##samp, coord)\n\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n\n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCCOORD3;\n         // float4 texcoord1 : TEXCCOORD4;\n         // float4 texcoord2 : TEXCCOORD5;\n         // float4 texcoord3 : TEXCCOORD6;\n         // float4 screenPos : TEXCOORD7;\n         // float4 color : COLOR;\n\n         // float4 extraData0 : TEXCOORD12;\n         // float4 extraData1 : TEXCOORD13;\n         // float4 extraData2 : TEXCOORD14;\n         // float4 extraData3 : TEXCOORD15;\n            \n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD9;\n         #endif\n            float4 fogFactorAndVertexLight : TEXCOORD10;\n            float4 shadowCoord : TEXCOORD11;\n         #if UNITY_ANY_INSTANCING_ENABLED\n            uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n            uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n            uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n            FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n      };\n\n\n         \n            \n            // data describing the user output of a pixel\n            struct LightingInputs\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half Alpha;\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half Anisotropy;\n               half iridescenceMask;\n               half iridescenceThickness;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n\n               float3x3 TBNMatrix;\n            };\n\n            struct VertexData\n            {\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n            \n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n\n               \n               // float4 extraData0 : TEXCOORD4;\n               // float4 extraData1 : TEXCOORD5;\n               // float4 extraData2 : TEXCOORD6;\n               // float4 extraData3 : TEXCOORD7;\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraData\n            {\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), p); };\n               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), p); };\n               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }\n               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }\n            #endif\n\n\n            \n         CBUFFER_START(UnityPerMaterial)\n\n            \thalf4 _Tint;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half _EmissionStrength;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n\n\n         CBUFFER_END\n\n\n         \n   half3 BlendDetailNormal(half3 n1, half3 n2)\n   {\n      return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n   }\n\n   // We share samplers with the albedo - which free's up more for stacking.\n\n   UNITY_DECLARE_TEX2D(_AlbedoMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_NormalMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_MaskMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_EmissionMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_DetailMap);\n\n\n\tvoid SurfaceFunction(inout LightingInputs o, ShaderData d)\n\t{\n      float2 uv = d.texcoord0.xy * _AlbedoMap_ST.xy + _AlbedoMap_ST.zw;\n\n      half4 c = UNITY_SAMPLE_TEX2D(_AlbedoMap, uv);\n      o.Albedo = c.rgb * _Tint.rgb;\n\t\to.Normal = UnpackScaleNormal(UNITY_SAMPLE_TEX2D_SAMPLER(_NormalMap, _AlbedoMap, uv), _NormalStrength);\n\n      half detailMask = 1;\n      #if _MASKMAP\n          // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = UNITY_SAMPLE_TEX2D_SAMPLER(_MaskMap, _AlbedoMap, uv);\n         o.Metallic = mask.r;\n         o.Occlusion = mask.g;\n         o.Smoothness = mask.a;\n         detailMask = mask.b;\n      #endif // separate maps\n\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap, _AlbedoMap, uv).rgb * _EmissionStrength;\n      #endif\n\n      #if defined(_DETAIL)\n         float2 detailUV = uv * _DetailMap_ST.xy + _DetailMap_ST.zw;\n         half4 detailSample = UNITY_SAMPLE_TEX2D_SAMPLER(_DetailMap, _AlbedoMap, detailUV);\n         o.Normal = BlendDetailNormal(o.Normal, UnpackScaleNormal(detailSample, _DetailNormalStrength * detailMask));\n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * detailSample.z, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n\n\t\to.Alpha = c.a;\n\t}\n\n\n\n        \n            void ChainSurfaceFunction(inout LightingInputs l, ShaderData d)\n            {\n                   SurfaceFunction(l, d);\n                 // SurfaceFunction_Ext1(l, d);\n                 // SurfaceFunction_Ext2(l, d);\n                 // SurfaceFunction_Ext3(l, d);\n                 // SurfaceFunction_Ext4(l, d);\n                 // SurfaceFunction_Ext5(l, d);\n                 // SurfaceFunction_Ext6(l, d);\n                 // SurfaceFunction_Ext7(l, d);\n                 // SurfaceFunction_Ext8(l, d);\n                 // SurfaceFunction_Ext9(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraData d = (ExtraData)0;\n                 //  ModifyVertex(v, d);\n                 // ModifyVertex_Ext1(v, d);\n                 // ModifyVertex_Ext2(v, d);\n                 // ModifyVertex_Ext3(v, d);\n                 // ModifyVertex_Ext4(v, d);\n                 // ModifyVertex_Ext5(v, d);\n                 // ModifyVertex_Ext6(v, d);\n                 // ModifyVertex_Ext7(v, d);\n                 // ModifyVertex_Ext8(v, d);\n                 // ModifyVertex_Ext9(v, d);\n                 // v2p.extraData0 = d.extraData0;\n                 // v2p.extraData1 = d.extraData1;\n                 // v2p.extraData2 = d.extraData2;\n                 // v2p.extraData3 = d.extraData3;\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraData d = (ExtraData)0;\n               //  ModifyTessellatedVertex(v, d);\n               // ModifyTessellatedVertex_Ext1(v, d);\n               // ModifyTessellatedVertex_Ext2(v, d);\n               // ModifyTessellatedVertex_Ext3(v, d);\n               // ModifyTessellatedVertex_Ext4(v, d);\n               // ModifyTessellatedVertex_Ext5(v, d);\n               // ModifyTessellatedVertex_Ext6(v, d);\n               // ModifyTessellatedVertex_Ext7(v, d);\n               // ModifyTessellatedVertex_Ext8(v, d);\n               // ModifyTessellatedVertex_Ext9(v, d);\n               // v2p.extraData0 = d.extraData0;\n               // v2p.extraData1 = d.extraData1;\n               // v2p.extraData2 = d.extraData2;\n               // v2p.extraData3 = d.extraData3;\n            }\n\n\n\n         \n\n         ShaderData CreateShaderData(VertexToPixel i)\n         {\n            ShaderData d = (ShaderData)0;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = i.worldNormal;\n            d.worldSpaceTangent = i.worldTangent.xyz;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n            // d.texcoord3 = i.texcoord3;\n            // d.vertexColor = i.color;\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            // d.localSpacePosition = mul(GetWorldToObjectMatrix(), i.worldPos);\n            // d.localSpaceNormal = mul(GetWorldToObjectMatrix(), i.worldNormal);\n            // d.localSpaceTangent = mul(GetWorldToObjectMatrix(), i.worldTangent.xyz);\n\n            // d.screenPos = i.screenPos;\n            // d.screenUV = i.screenPos.xy / i.screenPos.w;\n\n            // d.extraData0 = i.extraData0;\n            // d.extraData1 = i.extraData1;\n            // d.extraData2 = i.extraData2;\n            // d.extraData3 = i.extraData3;\n\n            return d;\n         }\n         \n\n         #if defined(SHADERPASS_SHADOWCASTER)\n            float3 _LightDirection;\n         #endif\n\n         \n         #if defined(SHADERPASS_SHADOWCASTER)\n            float3 _LightDirection;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n           // o.texcoord3 = v.texcoord3;\n           // o.color = v.color;\n\n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n          #if defined(SHADERPASS_SHADOWCASTER)\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, _LightDirection));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif defined(SHADERPASS_META)\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1, v.texcoord2, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n\n              // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          \n\n          #if defined(SHADERPASS_FORWARD)\n              OUTPUT_LIGHTMAP_UV(o.uv1, unity_LightmapST, output.lightmapUV);\n              OUTPUT_SH(o.worldNormal, o.sh);\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n              half fogFactor = ComputeFogFactor(o.pos.z);\n              o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n          #endif\n\n          #ifdef _MAIN_LIGHT_SHADOWS\n              o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n         \n\n         // fragment shader\n         half4 Frag (VertexToPixel IN) : SV_Target\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n           ShaderData d = CreateShaderData(IN);\n\n           LightingInputs l = (LightingInputs)0;\n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n           #ifdef _USESPECULAR\n              float3 specular = l.Specular;\n              float metallic = 1;\n           #else   \n              float3 specular = 0;\n              float metallic = l.Metallic;\n          #endif\n\n          InputData inputData;\n\n           inputData.positionWS = IN.worldPos;\n           inputData.normalWS = mul(l.Normal, d.TBNMatrix);\n           inputData.viewDirectionWS = d.worldSpaceViewDir;\n\n\n          #if defined(MAIN_LIGHT_CALCULATE_SHADOWS)\n              inputData.shadowCoord = TransformWorldToShadowCoord(IN.worldPos);\n          #else\n              inputData.shadowCoord = float4(0, 0, 0, 0);\n          #endif\n\n          inputData.fogCoord = IN.fogFactorAndVertexLight.x;\n          inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;\n          inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.sh, inputData.normalWS);\n\n\n          half4 color = UniversalFragmentPBR(\n            inputData,\n            l.Albedo,\n            metallic,\n            specular,\n            l.Smoothness,\n            l.Occlusion,\n            l.Emission,\n            l.Alpha); \n\n          color.rgb = MixFog(color.rgb, inputData.fogCoord);\n\n          // FinalColorForward(l, d, color);\n\n          return color;\n\n         }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            Name \"ShadowCaster\"\n            Tags \n            { \n                \"LightMode\" = \"ShadowCaster\"\n            }\n           \n            // Render State\n            Blend One Zero, One Zero\n            Cull Back\n            ZTest LEqual\n            ZWrite On\n            // ColorMask: <None>\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_instancing\n        \n            \n\n                 \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n        \n\n               #pragma shader_feature_local _ _MASKMAP\n   #pragma shader_feature_local _ _DETAIL\n   #pragma shader_feature_local _ _EMISSION\n\n   #define _URP 1\n\n\n                  #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler_##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler_##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler_##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler_##samp, coord)\n\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n\n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCCOORD3;\n         // float4 texcoord1 : TEXCCOORD4;\n         // float4 texcoord2 : TEXCCOORD5;\n         // float4 texcoord3 : TEXCCOORD6;\n         // float4 screenPos : TEXCOORD7;\n         // float4 color : COLOR;\n\n         // float4 extraData0 : TEXCOORD12;\n         // float4 extraData1 : TEXCOORD13;\n         // float4 extraData2 : TEXCOORD14;\n         // float4 extraData3 : TEXCOORD15;\n            \n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD9;\n         #endif\n            float4 fogFactorAndVertexLight : TEXCOORD10;\n            float4 shadowCoord : TEXCOORD11;\n         #if UNITY_ANY_INSTANCING_ENABLED\n            uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n            uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n            uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n            FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n      };\n\n         \n            \n            \n            // data describing the user output of a pixel\n            struct LightingInputs\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half Alpha;\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half Anisotropy;\n               half iridescenceMask;\n               half iridescenceThickness;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n\n               float3x3 TBNMatrix;\n            };\n\n            struct VertexData\n            {\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n            \n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n\n               \n               // float4 extraData0 : TEXCOORD4;\n               // float4 extraData1 : TEXCOORD5;\n               // float4 extraData2 : TEXCOORD6;\n               // float4 extraData3 : TEXCOORD7;\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraData\n            {\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), p); };\n               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), p); };\n               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }\n               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }\n            #endif\n\n\n            \n            CBUFFER_START(UnityPerMaterial)\n\n               \thalf4 _Tint;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half _EmissionStrength;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n\n\n            CBUFFER_END\n\n            \n   half3 BlendDetailNormal(half3 n1, half3 n2)\n   {\n      return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n   }\n\n   // We share samplers with the albedo - which free's up more for stacking.\n\n   UNITY_DECLARE_TEX2D(_AlbedoMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_NormalMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_MaskMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_EmissionMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_DetailMap);\n\n\n\tvoid SurfaceFunction(inout LightingInputs o, ShaderData d)\n\t{\n      float2 uv = d.texcoord0.xy * _AlbedoMap_ST.xy + _AlbedoMap_ST.zw;\n\n      half4 c = UNITY_SAMPLE_TEX2D(_AlbedoMap, uv);\n      o.Albedo = c.rgb * _Tint.rgb;\n\t\to.Normal = UnpackScaleNormal(UNITY_SAMPLE_TEX2D_SAMPLER(_NormalMap, _AlbedoMap, uv), _NormalStrength);\n\n      half detailMask = 1;\n      #if _MASKMAP\n          // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = UNITY_SAMPLE_TEX2D_SAMPLER(_MaskMap, _AlbedoMap, uv);\n         o.Metallic = mask.r;\n         o.Occlusion = mask.g;\n         o.Smoothness = mask.a;\n         detailMask = mask.b;\n      #endif // separate maps\n\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap, _AlbedoMap, uv).rgb * _EmissionStrength;\n      #endif\n\n      #if defined(_DETAIL)\n         float2 detailUV = uv * _DetailMap_ST.xy + _DetailMap_ST.zw;\n         half4 detailSample = UNITY_SAMPLE_TEX2D_SAMPLER(_DetailMap, _AlbedoMap, detailUV);\n         o.Normal = BlendDetailNormal(o.Normal, UnpackScaleNormal(detailSample, _DetailNormalStrength * detailMask));\n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * detailSample.z, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n\n\t\to.Alpha = c.a;\n\t}\n\n\n\n        \n            void ChainSurfaceFunction(inout LightingInputs l, ShaderData d)\n            {\n                   SurfaceFunction(l, d);\n                 // SurfaceFunction_Ext1(l, d);\n                 // SurfaceFunction_Ext2(l, d);\n                 // SurfaceFunction_Ext3(l, d);\n                 // SurfaceFunction_Ext4(l, d);\n                 // SurfaceFunction_Ext5(l, d);\n                 // SurfaceFunction_Ext6(l, d);\n                 // SurfaceFunction_Ext7(l, d);\n                 // SurfaceFunction_Ext8(l, d);\n                 // SurfaceFunction_Ext9(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraData d = (ExtraData)0;\n                 //  ModifyVertex(v, d);\n                 // ModifyVertex_Ext1(v, d);\n                 // ModifyVertex_Ext2(v, d);\n                 // ModifyVertex_Ext3(v, d);\n                 // ModifyVertex_Ext4(v, d);\n                 // ModifyVertex_Ext5(v, d);\n                 // ModifyVertex_Ext6(v, d);\n                 // ModifyVertex_Ext7(v, d);\n                 // ModifyVertex_Ext8(v, d);\n                 // ModifyVertex_Ext9(v, d);\n                 // v2p.extraData0 = d.extraData0;\n                 // v2p.extraData1 = d.extraData1;\n                 // v2p.extraData2 = d.extraData2;\n                 // v2p.extraData3 = d.extraData3;\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraData d = (ExtraData)0;\n               //  ModifyTessellatedVertex(v, d);\n               // ModifyTessellatedVertex_Ext1(v, d);\n               // ModifyTessellatedVertex_Ext2(v, d);\n               // ModifyTessellatedVertex_Ext3(v, d);\n               // ModifyTessellatedVertex_Ext4(v, d);\n               // ModifyTessellatedVertex_Ext5(v, d);\n               // ModifyTessellatedVertex_Ext6(v, d);\n               // ModifyTessellatedVertex_Ext7(v, d);\n               // ModifyTessellatedVertex_Ext8(v, d);\n               // ModifyTessellatedVertex_Ext9(v, d);\n               // v2p.extraData0 = d.extraData0;\n               // v2p.extraData1 = d.extraData1;\n               // v2p.extraData2 = d.extraData2;\n               // v2p.extraData3 = d.extraData3;\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i)\n         {\n            ShaderData d = (ShaderData)0;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = i.worldNormal;\n            d.worldSpaceTangent = i.worldTangent.xyz;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n            // d.texcoord3 = i.texcoord3;\n            // d.vertexColor = i.color;\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            // d.localSpacePosition = mul(GetWorldToObjectMatrix(), i.worldPos);\n            // d.localSpaceNormal = mul(GetWorldToObjectMatrix(), i.worldNormal);\n            // d.localSpaceTangent = mul(GetWorldToObjectMatrix(), i.worldTangent.xyz);\n\n            // d.screenPos = i.screenPos;\n            // d.screenUV = i.screenPos.xy / i.screenPos.w;\n\n            // d.extraData0 = i.extraData0;\n            // d.extraData1 = i.extraData1;\n            // d.extraData2 = i.extraData2;\n            // d.extraData3 = i.extraData3;\n\n            return d;\n         }\n         \n\n            \n         #if defined(SHADERPASS_SHADOWCASTER)\n            float3 _LightDirection;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n           // o.texcoord3 = v.texcoord3;\n           // o.color = v.color;\n\n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n          #if defined(SHADERPASS_SHADOWCASTER)\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, _LightDirection));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif defined(SHADERPASS_META)\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1, v.texcoord2, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n\n              // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          \n\n          #if defined(SHADERPASS_FORWARD)\n              OUTPUT_LIGHTMAP_UV(o.uv1, unity_LightmapST, output.lightmapUV);\n              OUTPUT_SH(o.worldNormal, o.sh);\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n              half fogFactor = ComputeFogFactor(o.pos.z);\n              o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n          #endif\n\n          #ifdef _MAIN_LIGHT_SHADOWS\n              o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n            \n\n            // fragment shader\n            half4 Frag (VertexToPixel IN) : SV_Target\n            {\n               UNITY_SETUP_INSTANCE_ID(IN);\n\n               ShaderData d = CreateShaderData(IN);\n\n               LightingInputs l = (LightingInputs)0;\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n               l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n               l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n             return 0;\n\n            }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            Name \"DepthOnly\"\n            Tags \n            { \n                \"LightMode\" = \"DepthOnly\"\n            }\n           \n            // Render State\n            Blend One Zero, One Zero\n            Cull Back\n            ZTest LEqual\n            ZWrite On\n            ColorMask 0\n            \n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #define SHADERPASS_DEPTHONLY\n\n            #pragma target 3.0\n\n                 \n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n        \n\n               #pragma shader_feature_local _ _MASKMAP\n   #pragma shader_feature_local _ _DETAIL\n   #pragma shader_feature_local _ _EMISSION\n\n   #define _URP 1\n\n\n                  #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler_##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler_##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler_##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler_##samp, coord)\n\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n\n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCCOORD3;\n         // float4 texcoord1 : TEXCCOORD4;\n         // float4 texcoord2 : TEXCCOORD5;\n         // float4 texcoord3 : TEXCCOORD6;\n         // float4 screenPos : TEXCOORD7;\n         // float4 color : COLOR;\n\n         // float4 extraData0 : TEXCOORD12;\n         // float4 extraData1 : TEXCOORD13;\n         // float4 extraData2 : TEXCOORD14;\n         // float4 extraData3 : TEXCOORD15;\n            \n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD9;\n         #endif\n            float4 fogFactorAndVertexLight : TEXCOORD10;\n            float4 shadowCoord : TEXCOORD11;\n         #if UNITY_ANY_INSTANCING_ENABLED\n            uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n            uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n            uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n            FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n      };\n\n         \n            \n            \n            // data describing the user output of a pixel\n            struct LightingInputs\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half Alpha;\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half Anisotropy;\n               half iridescenceMask;\n               half iridescenceThickness;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n\n               float3x3 TBNMatrix;\n            };\n\n            struct VertexData\n            {\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n            \n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n\n               \n               // float4 extraData0 : TEXCOORD4;\n               // float4 extraData1 : TEXCOORD5;\n               // float4 extraData2 : TEXCOORD6;\n               // float4 extraData3 : TEXCOORD7;\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraData\n            {\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), p); };\n               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), p); };\n               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }\n               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }\n            #endif\n\n\n            \n            CBUFFER_START(UnityPerMaterial)\n\n               \thalf4 _Tint;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half _EmissionStrength;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n\n\n            CBUFFER_END\n\n            \n   half3 BlendDetailNormal(half3 n1, half3 n2)\n   {\n      return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n   }\n\n   // We share samplers with the albedo - which free's up more for stacking.\n\n   UNITY_DECLARE_TEX2D(_AlbedoMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_NormalMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_MaskMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_EmissionMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_DetailMap);\n\n\n\tvoid SurfaceFunction(inout LightingInputs o, ShaderData d)\n\t{\n      float2 uv = d.texcoord0.xy * _AlbedoMap_ST.xy + _AlbedoMap_ST.zw;\n\n      half4 c = UNITY_SAMPLE_TEX2D(_AlbedoMap, uv);\n      o.Albedo = c.rgb * _Tint.rgb;\n\t\to.Normal = UnpackScaleNormal(UNITY_SAMPLE_TEX2D_SAMPLER(_NormalMap, _AlbedoMap, uv), _NormalStrength);\n\n      half detailMask = 1;\n      #if _MASKMAP\n          // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = UNITY_SAMPLE_TEX2D_SAMPLER(_MaskMap, _AlbedoMap, uv);\n         o.Metallic = mask.r;\n         o.Occlusion = mask.g;\n         o.Smoothness = mask.a;\n         detailMask = mask.b;\n      #endif // separate maps\n\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap, _AlbedoMap, uv).rgb * _EmissionStrength;\n      #endif\n\n      #if defined(_DETAIL)\n         float2 detailUV = uv * _DetailMap_ST.xy + _DetailMap_ST.zw;\n         half4 detailSample = UNITY_SAMPLE_TEX2D_SAMPLER(_DetailMap, _AlbedoMap, detailUV);\n         o.Normal = BlendDetailNormal(o.Normal, UnpackScaleNormal(detailSample, _DetailNormalStrength * detailMask));\n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * detailSample.z, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n\n\t\to.Alpha = c.a;\n\t}\n\n\n\n        \n            void ChainSurfaceFunction(inout LightingInputs l, ShaderData d)\n            {\n                   SurfaceFunction(l, d);\n                 // SurfaceFunction_Ext1(l, d);\n                 // SurfaceFunction_Ext2(l, d);\n                 // SurfaceFunction_Ext3(l, d);\n                 // SurfaceFunction_Ext4(l, d);\n                 // SurfaceFunction_Ext5(l, d);\n                 // SurfaceFunction_Ext6(l, d);\n                 // SurfaceFunction_Ext7(l, d);\n                 // SurfaceFunction_Ext8(l, d);\n                 // SurfaceFunction_Ext9(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraData d = (ExtraData)0;\n                 //  ModifyVertex(v, d);\n                 // ModifyVertex_Ext1(v, d);\n                 // ModifyVertex_Ext2(v, d);\n                 // ModifyVertex_Ext3(v, d);\n                 // ModifyVertex_Ext4(v, d);\n                 // ModifyVertex_Ext5(v, d);\n                 // ModifyVertex_Ext6(v, d);\n                 // ModifyVertex_Ext7(v, d);\n                 // ModifyVertex_Ext8(v, d);\n                 // ModifyVertex_Ext9(v, d);\n                 // v2p.extraData0 = d.extraData0;\n                 // v2p.extraData1 = d.extraData1;\n                 // v2p.extraData2 = d.extraData2;\n                 // v2p.extraData3 = d.extraData3;\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraData d = (ExtraData)0;\n               //  ModifyTessellatedVertex(v, d);\n               // ModifyTessellatedVertex_Ext1(v, d);\n               // ModifyTessellatedVertex_Ext2(v, d);\n               // ModifyTessellatedVertex_Ext3(v, d);\n               // ModifyTessellatedVertex_Ext4(v, d);\n               // ModifyTessellatedVertex_Ext5(v, d);\n               // ModifyTessellatedVertex_Ext6(v, d);\n               // ModifyTessellatedVertex_Ext7(v, d);\n               // ModifyTessellatedVertex_Ext8(v, d);\n               // ModifyTessellatedVertex_Ext9(v, d);\n               // v2p.extraData0 = d.extraData0;\n               // v2p.extraData1 = d.extraData1;\n               // v2p.extraData2 = d.extraData2;\n               // v2p.extraData3 = d.extraData3;\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i)\n         {\n            ShaderData d = (ShaderData)0;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = i.worldNormal;\n            d.worldSpaceTangent = i.worldTangent.xyz;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n            // d.texcoord3 = i.texcoord3;\n            // d.vertexColor = i.color;\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            // d.localSpacePosition = mul(GetWorldToObjectMatrix(), i.worldPos);\n            // d.localSpaceNormal = mul(GetWorldToObjectMatrix(), i.worldNormal);\n            // d.localSpaceTangent = mul(GetWorldToObjectMatrix(), i.worldTangent.xyz);\n\n            // d.screenPos = i.screenPos;\n            // d.screenUV = i.screenPos.xy / i.screenPos.w;\n\n            // d.extraData0 = i.extraData0;\n            // d.extraData1 = i.extraData1;\n            // d.extraData2 = i.extraData2;\n            // d.extraData3 = i.extraData3;\n\n            return d;\n         }\n         \n\n            \n         #if defined(SHADERPASS_SHADOWCASTER)\n            float3 _LightDirection;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n           // o.texcoord3 = v.texcoord3;\n           // o.color = v.color;\n\n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n          #if defined(SHADERPASS_SHADOWCASTER)\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, _LightDirection));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif defined(SHADERPASS_META)\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1, v.texcoord2, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n\n              // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          \n\n          #if defined(SHADERPASS_FORWARD)\n              OUTPUT_LIGHTMAP_UV(o.uv1, unity_LightmapST, output.lightmapUV);\n              OUTPUT_SH(o.worldNormal, o.sh);\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n              half fogFactor = ComputeFogFactor(o.pos.z);\n              o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n          #endif\n\n          #ifdef _MAIN_LIGHT_SHADOWS\n              o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n            \n\n            // fragment shader\n            half4 Frag (VertexToPixel IN) : SV_Target\n            {\n               UNITY_SETUP_INSTANCE_ID(IN);\n               UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n               ShaderData d = CreateShaderData(IN);\n\n               LightingInputs l = (LightingInputs)0;\n\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n               l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n               l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n               return 0;\n\n            }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            Name \"Meta\"\n            Tags \n            { \n                \"LightMode\" = \"Meta\"\n            }\n\n             // Render State\n            Blend One Zero, One Zero\n            Cull Back\n            ZTest LEqual\n            ZWrite On\n            // ColorMask: <None>\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n        \n            #define SHADERPASS_META\n\n                 \n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/MetaInput.hlsl\"\n            #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n        \n\n               #pragma shader_feature_local _ _MASKMAP\n   #pragma shader_feature_local _ _DETAIL\n   #pragma shader_feature_local _ _EMISSION\n\n   #define _URP 1\n\n\n                  #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler_##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler_##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler_##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler_##samp, coord)\n\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n\n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCCOORD3;\n         // float4 texcoord1 : TEXCCOORD4;\n         // float4 texcoord2 : TEXCCOORD5;\n         // float4 texcoord3 : TEXCCOORD6;\n         // float4 screenPos : TEXCOORD7;\n         // float4 color : COLOR;\n\n         // float4 extraData0 : TEXCOORD12;\n         // float4 extraData1 : TEXCOORD13;\n         // float4 extraData2 : TEXCOORD14;\n         // float4 extraData3 : TEXCOORD15;\n            \n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD9;\n         #endif\n            float4 fogFactorAndVertexLight : TEXCOORD10;\n            float4 shadowCoord : TEXCOORD11;\n         #if UNITY_ANY_INSTANCING_ENABLED\n            uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n            uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n            uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n            FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n      };\n\n\n            \n            \n            // data describing the user output of a pixel\n            struct LightingInputs\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half Alpha;\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half Anisotropy;\n               half iridescenceMask;\n               half iridescenceThickness;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n\n               float3x3 TBNMatrix;\n            };\n\n            struct VertexData\n            {\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n            \n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n\n               \n               // float4 extraData0 : TEXCOORD4;\n               // float4 extraData1 : TEXCOORD5;\n               // float4 extraData2 : TEXCOORD6;\n               // float4 extraData3 : TEXCOORD7;\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraData\n            {\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), p); };\n               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), p); };\n               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }\n               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }\n            #endif\n\n\n            \n            CBUFFER_START(UnityPerMaterial)\n\n               \thalf4 _Tint;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half _EmissionStrength;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n\n\n            CBUFFER_END\n\n            \n   half3 BlendDetailNormal(half3 n1, half3 n2)\n   {\n      return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n   }\n\n   // We share samplers with the albedo - which free's up more for stacking.\n\n   UNITY_DECLARE_TEX2D(_AlbedoMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_NormalMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_MaskMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_EmissionMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_DetailMap);\n\n\n\tvoid SurfaceFunction(inout LightingInputs o, ShaderData d)\n\t{\n      float2 uv = d.texcoord0.xy * _AlbedoMap_ST.xy + _AlbedoMap_ST.zw;\n\n      half4 c = UNITY_SAMPLE_TEX2D(_AlbedoMap, uv);\n      o.Albedo = c.rgb * _Tint.rgb;\n\t\to.Normal = UnpackScaleNormal(UNITY_SAMPLE_TEX2D_SAMPLER(_NormalMap, _AlbedoMap, uv), _NormalStrength);\n\n      half detailMask = 1;\n      #if _MASKMAP\n          // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = UNITY_SAMPLE_TEX2D_SAMPLER(_MaskMap, _AlbedoMap, uv);\n         o.Metallic = mask.r;\n         o.Occlusion = mask.g;\n         o.Smoothness = mask.a;\n         detailMask = mask.b;\n      #endif // separate maps\n\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap, _AlbedoMap, uv).rgb * _EmissionStrength;\n      #endif\n\n      #if defined(_DETAIL)\n         float2 detailUV = uv * _DetailMap_ST.xy + _DetailMap_ST.zw;\n         half4 detailSample = UNITY_SAMPLE_TEX2D_SAMPLER(_DetailMap, _AlbedoMap, detailUV);\n         o.Normal = BlendDetailNormal(o.Normal, UnpackScaleNormal(detailSample, _DetailNormalStrength * detailMask));\n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * detailSample.z, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n\n\t\to.Alpha = c.a;\n\t}\n\n\n\n        \n            void ChainSurfaceFunction(inout LightingInputs l, ShaderData d)\n            {\n                   SurfaceFunction(l, d);\n                 // SurfaceFunction_Ext1(l, d);\n                 // SurfaceFunction_Ext2(l, d);\n                 // SurfaceFunction_Ext3(l, d);\n                 // SurfaceFunction_Ext4(l, d);\n                 // SurfaceFunction_Ext5(l, d);\n                 // SurfaceFunction_Ext6(l, d);\n                 // SurfaceFunction_Ext7(l, d);\n                 // SurfaceFunction_Ext8(l, d);\n                 // SurfaceFunction_Ext9(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraData d = (ExtraData)0;\n                 //  ModifyVertex(v, d);\n                 // ModifyVertex_Ext1(v, d);\n                 // ModifyVertex_Ext2(v, d);\n                 // ModifyVertex_Ext3(v, d);\n                 // ModifyVertex_Ext4(v, d);\n                 // ModifyVertex_Ext5(v, d);\n                 // ModifyVertex_Ext6(v, d);\n                 // ModifyVertex_Ext7(v, d);\n                 // ModifyVertex_Ext8(v, d);\n                 // ModifyVertex_Ext9(v, d);\n                 // v2p.extraData0 = d.extraData0;\n                 // v2p.extraData1 = d.extraData1;\n                 // v2p.extraData2 = d.extraData2;\n                 // v2p.extraData3 = d.extraData3;\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraData d = (ExtraData)0;\n               //  ModifyTessellatedVertex(v, d);\n               // ModifyTessellatedVertex_Ext1(v, d);\n               // ModifyTessellatedVertex_Ext2(v, d);\n               // ModifyTessellatedVertex_Ext3(v, d);\n               // ModifyTessellatedVertex_Ext4(v, d);\n               // ModifyTessellatedVertex_Ext5(v, d);\n               // ModifyTessellatedVertex_Ext6(v, d);\n               // ModifyTessellatedVertex_Ext7(v, d);\n               // ModifyTessellatedVertex_Ext8(v, d);\n               // ModifyTessellatedVertex_Ext9(v, d);\n               // v2p.extraData0 = d.extraData0;\n               // v2p.extraData1 = d.extraData1;\n               // v2p.extraData2 = d.extraData2;\n               // v2p.extraData3 = d.extraData3;\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i)\n         {\n            ShaderData d = (ShaderData)0;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = i.worldNormal;\n            d.worldSpaceTangent = i.worldTangent.xyz;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n            // d.texcoord3 = i.texcoord3;\n            // d.vertexColor = i.color;\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            // d.localSpacePosition = mul(GetWorldToObjectMatrix(), i.worldPos);\n            // d.localSpaceNormal = mul(GetWorldToObjectMatrix(), i.worldNormal);\n            // d.localSpaceTangent = mul(GetWorldToObjectMatrix(), i.worldTangent.xyz);\n\n            // d.screenPos = i.screenPos;\n            // d.screenUV = i.screenPos.xy / i.screenPos.w;\n\n            // d.extraData0 = i.extraData0;\n            // d.extraData1 = i.extraData1;\n            // d.extraData2 = i.extraData2;\n            // d.extraData3 = i.extraData3;\n\n            return d;\n         }\n         \n\n            \n         #if defined(SHADERPASS_SHADOWCASTER)\n            float3 _LightDirection;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n           // o.texcoord3 = v.texcoord3;\n           // o.color = v.color;\n\n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n          #if defined(SHADERPASS_SHADOWCASTER)\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, _LightDirection));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif defined(SHADERPASS_META)\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1, v.texcoord2, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n\n              // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          \n\n          #if defined(SHADERPASS_FORWARD)\n              OUTPUT_LIGHTMAP_UV(o.uv1, unity_LightmapST, output.lightmapUV);\n              OUTPUT_SH(o.worldNormal, o.sh);\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n              half fogFactor = ComputeFogFactor(o.pos.z);\n              o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n          #endif\n\n          #ifdef _MAIN_LIGHT_SHADOWS\n              o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n            \n\n            // fragment shader\n            half4 Frag (VertexToPixel IN) : SV_Target\n            {\n               UNITY_SETUP_INSTANCE_ID(IN);\n\n               ShaderData d = CreateShaderData(IN);\n\n               LightingInputs l = (LightingInputs)0;\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n               l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n               l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n               MetaInput metaInput = (MetaInput)0;\n               metaInput.Albedo = l.Albedo;\n               metaInput.Emission = l.Emission;\n\n               return MetaFragment(metaInput);\n\n            }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            // Name: <None>\n            Tags \n            { \n                \"LightMode\" = \"Universal2D\"\n            }\n           \n            // Render State\n            Blend One Zero, One Zero\n            Cull Back\n            ZTest LEqual\n            ZWrite On\n            // ColorMask: <None>\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_instancing\n        \n            #define SHADERPASS_2D\n\n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n        \n\n               #pragma shader_feature_local _ _MASKMAP\n   #pragma shader_feature_local _ _DETAIL\n   #pragma shader_feature_local _ _EMISSION\n\n   #define _URP 1\n\n\n                  #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler_##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler_##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler_##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler_##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler_##samp, coord)\n\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n\n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCCOORD3;\n         // float4 texcoord1 : TEXCCOORD4;\n         // float4 texcoord2 : TEXCCOORD5;\n         // float4 texcoord3 : TEXCCOORD6;\n         // float4 screenPos : TEXCOORD7;\n         // float4 color : COLOR;\n\n         // float4 extraData0 : TEXCOORD12;\n         // float4 extraData1 : TEXCOORD13;\n         // float4 extraData2 : TEXCOORD14;\n         // float4 extraData3 : TEXCOORD15;\n            \n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD9;\n         #endif\n            float4 fogFactorAndVertexLight : TEXCOORD10;\n            float4 shadowCoord : TEXCOORD11;\n         #if UNITY_ANY_INSTANCING_ENABLED\n            uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n            uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n            uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n            FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n      };\n\n\n\n            \n            \n            // data describing the user output of a pixel\n            struct LightingInputs\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half Alpha;\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half Anisotropy;\n               half iridescenceMask;\n               half iridescenceThickness;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n\n               float3x3 TBNMatrix;\n            };\n\n            struct VertexData\n            {\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n            \n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n               // float4 texcoord3 : TEXCOORD3;\n               // float4 vertexColor : COLOR;\n\n               \n               // float4 extraData0 : TEXCOORD4;\n               // float4 extraData1 : TEXCOORD5;\n               // float4 extraData2 : TEXCOORD6;\n               // float4 extraData3 : TEXCOORD7;\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraData\n            {\n               float4 extraData0;\n               float4 extraData1;\n               float4 extraData2;\n               float4 extraData3;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // GetWorldToObjectMatrix() in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(GetWorldToObjectMatrix(), p); };\n               float3 TransformObjectToWorld(float3 p) { return mul(GetObjectToWorldMatrix(), p); };\n               float4x4 GetWorldToObjectMatrix() { return GetWorldToObjectMatrix(); }\n               float4x4 GetObjectToWorldMatrix() { return GetObjectToWorldMatrix(); }\n            #endif\n\n\n            \n            CBUFFER_START(UnityPerMaterial)\n\n               \thalf4 _Tint;\n   float4 _AlbedoMap_ST;\n   float4 _DetailMap_ST;\n   half _NormalStrength;\n   half _EmissionStrength;\n   half _DetailAlbedoStrength;\n   half _DetailNormalStrength;\n   half _DetailSmoothnessStrength;\n\n\n            CBUFFER_END\n\n            \n   half3 BlendDetailNormal(half3 n1, half3 n2)\n   {\n      return normalize(half3(n1.xy + n2.xy, n1.z*n2.z));\n   }\n\n   // We share samplers with the albedo - which free's up more for stacking.\n\n   UNITY_DECLARE_TEX2D(_AlbedoMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_NormalMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_MaskMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_EmissionMap);\n   UNITY_DECLARE_TEX2D_NOSAMPLER(_DetailMap);\n\n\n\tvoid SurfaceFunction(inout LightingInputs o, ShaderData d)\n\t{\n      float2 uv = d.texcoord0.xy * _AlbedoMap_ST.xy + _AlbedoMap_ST.zw;\n\n      half4 c = UNITY_SAMPLE_TEX2D(_AlbedoMap, uv);\n      o.Albedo = c.rgb * _Tint.rgb;\n\t\to.Normal = UnpackScaleNormal(UNITY_SAMPLE_TEX2D_SAMPLER(_NormalMap, _AlbedoMap, uv), _NormalStrength);\n\n      half detailMask = 1;\n      #if _MASKMAP\n          // Unity mask map format (R) Metallic, (G) Occlusion, (B) Detail Mask (A) Smoothness\n         half4 mask = UNITY_SAMPLE_TEX2D_SAMPLER(_MaskMap, _AlbedoMap, uv);\n         o.Metallic = mask.r;\n         o.Occlusion = mask.g;\n         o.Smoothness = mask.a;\n         detailMask = mask.b;\n      #endif // separate maps\n\n\n      half3 emission = 0;\n      #if defined(_EMISSION)\n         o.Emission = UNITY_SAMPLE_TEX2D_SAMPLER(_EmissionMap, _AlbedoMap, uv).rgb * _EmissionStrength;\n      #endif\n\n      #if defined(_DETAIL)\n         float2 detailUV = uv * _DetailMap_ST.xy + _DetailMap_ST.zw;\n         half4 detailSample = UNITY_SAMPLE_TEX2D_SAMPLER(_DetailMap, _AlbedoMap, detailUV);\n         o.Normal = BlendDetailNormal(o.Normal, UnpackScaleNormal(detailSample, _DetailNormalStrength * detailMask));\n         o.Albedo = lerp(o.Albedo, o.Albedo * 2 * detailSample.x,  detailMask * _DetailAlbedoStrength);\n         o.Smoothness = lerp(o.Smoothness, o.Smoothness * 2 * detailSample.z, detailMask * _DetailSmoothnessStrength);\n      #endif\n\n\n\t\to.Alpha = c.a;\n\t}\n\n\n\n        \n            void ChainSurfaceFunction(inout LightingInputs l, ShaderData d)\n            {\n                   SurfaceFunction(l, d);\n                 // SurfaceFunction_Ext1(l, d);\n                 // SurfaceFunction_Ext2(l, d);\n                 // SurfaceFunction_Ext3(l, d);\n                 // SurfaceFunction_Ext4(l, d);\n                 // SurfaceFunction_Ext5(l, d);\n                 // SurfaceFunction_Ext6(l, d);\n                 // SurfaceFunction_Ext7(l, d);\n                 // SurfaceFunction_Ext8(l, d);\n                 // SurfaceFunction_Ext9(l, d);\n            }\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n                 ExtraData d = (ExtraData)0;\n                 //  ModifyVertex(v, d);\n                 // ModifyVertex_Ext1(v, d);\n                 // ModifyVertex_Ext2(v, d);\n                 // ModifyVertex_Ext3(v, d);\n                 // ModifyVertex_Ext4(v, d);\n                 // ModifyVertex_Ext5(v, d);\n                 // ModifyVertex_Ext6(v, d);\n                 // ModifyVertex_Ext7(v, d);\n                 // ModifyVertex_Ext8(v, d);\n                 // ModifyVertex_Ext9(v, d);\n                 // v2p.extraData0 = d.extraData0;\n                 // v2p.extraData1 = d.extraData1;\n                 // v2p.extraData2 = d.extraData2;\n                 // v2p.extraData3 = d.extraData3;\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraData d = (ExtraData)0;\n               //  ModifyTessellatedVertex(v, d);\n               // ModifyTessellatedVertex_Ext1(v, d);\n               // ModifyTessellatedVertex_Ext2(v, d);\n               // ModifyTessellatedVertex_Ext3(v, d);\n               // ModifyTessellatedVertex_Ext4(v, d);\n               // ModifyTessellatedVertex_Ext5(v, d);\n               // ModifyTessellatedVertex_Ext6(v, d);\n               // ModifyTessellatedVertex_Ext7(v, d);\n               // ModifyTessellatedVertex_Ext8(v, d);\n               // ModifyTessellatedVertex_Ext9(v, d);\n               // v2p.extraData0 = d.extraData0;\n               // v2p.extraData1 = d.extraData1;\n               // v2p.extraData2 = d.extraData2;\n               // v2p.extraData3 = d.extraData3;\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel i)\n         {\n            ShaderData d = (ShaderData)0;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = i.worldNormal;\n            d.worldSpaceTangent = i.worldTangent.xyz;\n            float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * i.worldTangent.w;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n            // d.texcoord3 = i.texcoord3;\n            // d.vertexColor = i.color;\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            // d.localSpacePosition = mul(GetWorldToObjectMatrix(), i.worldPos);\n            // d.localSpaceNormal = mul(GetWorldToObjectMatrix(), i.worldNormal);\n            // d.localSpaceTangent = mul(GetWorldToObjectMatrix(), i.worldTangent.xyz);\n\n            // d.screenPos = i.screenPos;\n            // d.screenUV = i.screenPos.xy / i.screenPos.w;\n\n            // d.extraData0 = i.extraData0;\n            // d.extraData1 = i.extraData1;\n            // d.extraData2 = i.extraData2;\n            // d.extraData3 = i.extraData3;\n\n            return d;\n         }\n         \n\n            \n         #if defined(SHADERPASS_SHADOWCASTER)\n            float3 _LightDirection;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n           // o.texcoord3 = v.texcoord3;\n           // o.color = v.color;\n\n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n          #if defined(SHADERPASS_SHADOWCASTER)\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, _LightDirection));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif defined(SHADERPASS_META)\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1, v.texcoord2, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n\n              // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          \n\n          #if defined(SHADERPASS_FORWARD)\n              OUTPUT_LIGHTMAP_UV(o.uv1, unity_LightmapST, output.lightmapUV);\n              OUTPUT_SH(o.worldNormal, o.sh);\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n              half fogFactor = ComputeFogFactor(o.pos.z);\n              o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n          #endif\n\n          #ifdef _MAIN_LIGHT_SHADOWS\n              o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n            \n\n            // fragment shader\n            half4 Frag (VertexToPixel IN) : SV_Target\n            {\n               UNITY_SETUP_INSTANCE_ID(IN);\n               UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n\n               ShaderData d = CreateShaderData(IN);\n\n               LightingInputs l = (LightingInputs)0;\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n               l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n               l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n               \n               half4 color = half4(l.Albedo, l.Alpha);\n\n               return color;\n\n            }\n\n         ENDHLSL\n\n      }\n\n\n\n   }\n   \n   \n}\n"}]}}